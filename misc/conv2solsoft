#!/usr/bin/perl
# conv2solsoft
# A Network Security Policy Compiler
# http://netspoc.berlios.de
# (c) 2009 by Heinz Knutzen <heinzknutzen@users.berlios.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# $Id$

use strict;
use warnings;
use File::Spec ();
use File::Basename ();

# Get directory of this script.
# If this script is called setuid it is running in taint mode.
# We can untaint the directory part of the script name,
# because it is set by calling C wrapper script 
# and can't be modified by the calling user.
my $path;
BEGIN {
    $path = File::Basename::dirname(File::Spec->rel2abs($0));
    $path =~ /(.*)/;	# untaint
    $path = $1;
}
use lib $path;
use Netspoc;
#use bytes;

use Encode;


####################################################################
# Main program
####################################################################

my($in_path) =  shift @ARGV;
$in_path or die "Usage: $0  {in-directory | in-file | -}\n";
&show_version();
&read_file_or_dir($in_path);
&show_read_statistics();
#&order_services();
&link_topology();
&mark_disabled();
&distribute_nat_info();
&find_subnets();
&setany();
&setpath();
# Abort now, if there are syntax errors and simple semantic errors.
die "Aborted with $error_counter error(s)\n" if $error_counter;

# Automatically terminate lines.
$\ = "\n";

# Encode output as Latin1.
binmode(STDOUT, ":encoding(latin1)");

my %model2type = (
    IOS    => [ 'pep.ios.router', '12.4' ],
    IOS_FW => [ 'pep.ios.router', '12.4', 'propFfs=yes' ],
    PIX    => [ 'pep.pix5', '6.3' ],
    ASA    => [ 'pep.pix5.asa', '8.0' ],
    Linux  => [ 'pep.netfilter', '1.3' ],
    VPN3K  => [ 'pep.vpn3000', '4.7' ],
);

my @routers  = grep { not $_->{disabled} } values %routers;
my @networks = grep { not $_->{disabled} } values %networks;
my @hosts    = grep { not $_->{disabled} } values %hosts;
my @groups   = values %groups;
my @services = values %services;
my @servicegroups = values %servicegroups;
my @policies = values %policies;

my %used_name = ('internet' => 'Internet');

# Solsoft needs unique names for all types recardless of case.
# Name must be max. 80 characters long (incl. "/" of network/class)
my $max = 79;
sub get_name ( $ ) {
    my($in) = @_;
    my($type, $name) = split(':', $in, 2);
    $name = substr($name, 0, $max);
    if($used_name{lc $name}) {
	$name = $in if $type;
	$name = substr($name, 0, $max);
	my $counter = 1;
	my $base = $name;
	while($used_name{lc $name}) {
	    my $extra = length($counter);
	    $base = substr($base, 0, ($max - $extra));
	    $name = "$base$counter";
	    $counter++;
	}
    }
    $used_name{lc $name} = $name;
#    my $len = length($name);
#    print STDERR "$len: $name" if $len > 80;
    return "\"$name\"";
}	

# Get router name before network names, because router name must not change.
for my $aref (\@routers, \@networks, \@hosts, 
	      \@groups, \@services, \@servicegroups) {
    for my $obj (@$aref) {
	my $name = get_name $obj->{name};
	$obj->{new_name} = $name;
    }
}
	
# Find hardware interfaces with multiple logical interfaces.
# Merge attached networks.
for my $router (@routers) {
    next if not $router->{managed};
#    print $router->{name};

    for my $hardware (@{$router->{hardware}}) {
#	print $hardware->{name};
	my @ips,

	# Networks attached to a single hardware interface.
	my %networks;
	for my $interface (@{$hardware->{interfaces}}) {
#	    print $interface->{name};
	    my $ip = $interface->{ip};
	    push @ips, $ip if $ip =~ /^\d+$/;
	    my $network = $interface->{network};
	    next if not $network->{ip} =~ /^\d+$/;
	    $networks{$network} = $network;
	}
       
	my @unknown;
	my @slaves;
	my %masters;
	for my $network (values %networks) {
	    if($network->{master}) {
		push @slaves, $network;
	    }
	    elsif($network->{slaves}) {
		$masters{$network} = $network;
	    }
	    else {
		push @unknown, $network;
	    }
	}

	# Find masters of current slaves.
	while (my $slave = pop @slaves) {
#	    print "Slave: $slave->{name}";
	    my $network = $slave->{master};
	    if($network->{master}) {
		push @slaves, $network;
	    }
	    else {
		$masters{$network} = $network;
	    }
	}
	my $n_masters = keys %masters;
	my $master;
	if($n_masters > 1) {
	    my $names = join ',', map {$_->{name}} values %masters;
	    die "Can't combine to single network: $names\n";
	}
	elsif(not $n_masters) {
	    $master = pop @unknown;
	}
	else {
	    ($master) = values %masters;
	}
	for my $network (@unknown) {
#	    print "Master: $master->{name}, Slave: $network->{name}";
	    $network->{master} = $master;
	    push @{$master->{slaves}}, $network;
	}
	$hardware->{ips} = \@ips,
	$hardware->{master_network} = $master;
    }
} 

# Print networks and hosts.
for my $network (@networks) {
    next if $network->{master};
    next if $network->{ip} eq 'tunnel';
    my $name = $network->{new_name};
    my @hosts;
    my @addr;
    for my $n ($network, @{$network->{slaves}}) {
	next if not $n->{ip} =~ /^\d+$/;
	my $ip = print_ip $n->{ip};
	my $prefix = Netspoc::mask2prefix $n->{mask};
	push @addr, "$ip/$prefix";
	push @hosts, @{$n->{hosts}};
    }

    # Print unnumbered network as nexus.
    if(not @addr) {
	@hosts and die "Unexpected hosts in $network->{name} wihout IP addresses\n";
	print "nexus $name void";
	next;
    }

    my $addr = join ',', @addr;
    print "network $name $addr";
    for my $host (@hosts) {
	@addr = ();
	my $host_name = "$name/$host->{new_name}";

	# Full qualified name is used later in metaclasses.
	$host->{new_name} = $host_name;
	if(my $ips = $host->{ips}) {
	    $addr = join ',', map { print_ip $_ } @$ips;
	}
	elsif(my $range = $host->{range}) {
	    my($l, $h) = @$range;
	    my @subnets = Netspoc::split_ip_range($l, $h);
	    for my $subnet (@subnets) {
		my($ip, $mask) = @$subnet;
		$ip = print_ip $ip;
		my $prefix = Netspoc::mask2prefix $mask;
		push @addr, "$ip/$prefix";
	    }
	    $addr = join ',', @addr;
	}
	print "class $host_name $addr";
    }
}

# Collect redundancy interfaces for generating limited path zones.
my @redundancy_interfaces;

# Print managed routers
for my $router (@routers) {
    next if not $router->{managed};
    my $name = $router->{new_name};
    my $model = $router->{model};
    my $at_silan;
    for my $interface (@{$router->{interfaces}}) {
	if(my $redundancy_interfaces = $interface->{redundancy_interfaces}) {
	    push @redundancy_interfaces, $redundancy_interfaces;
	}
	my $network = $interface->{network};
	if($network->{name} eq 'network:SI_LAN') {
	    $at_silan = 1;
	    last;
	}
    }
    my $type_info;
    if($at_silan) {
	$type_info = $model2type{$model->{name}} or 
	    die "Can't handle $name with model=$model\n";
    }
    else {
	$type_info = ['pep.unknown', '0.0'];
    }
    my($type, $version, $param) = @$type_info;
    my $append = $param ? " param($param)" : '';
    print "device $name $type $version$append";
    for my $hardware (@{$router->{hardware}}) {
	my $hw_name = $hardware->{name};
	my $net_name = $hardware->{master_network}->{new_name};
	my @ips = map { print_ip $_ } @{$hardware->{ips}};
	my $addr = @ips ? join ',', @ips : 'void';
	my $append = '';
	if($model->{has_interface_level}) {
	    my $level = $hardware->{level};
	    if($level == 100) {
		$append = 'param(domainType=inside)';
	    }
	}
	print "interface \"$hw_name\" $addr $net_name $append";
    }
    
    # Separate class for each interface.
#    for my $interface (@{$router->{interfaces}}) {
#	my $ip = $interface->{ip};
#	next if not $ip =~ /^\d+$/;
#	$ip = print_ip $ip;
#	my $net_name = $interface->{network}->{new_name};
#	my $class_name = "$name/$net_name";
#	$interface->{new_name} = $class_name;
#	print "class $class_name $ip";
#    }
	
}

# Print unmanaged routers as "nexus".
for my $router (@routers) {
    next if $router->{managed};
    my $name = $router->{new_name};
    my @ips;
    for my $interface (@{$router->{interfaces}}) {
	my $ip = $interface->{ip};
	next if not $ip =~ /^\d+$/;
	push @ips, $ip;
    }
    @ips = map { print_ip $_ } @ips;
    my $addr = @ips ? join ',', @ips : 'void';
    print "nexus $name $addr";

    # Prevent duplicate links from interfaces with multiple IP addresses.
    my %duplicate;
    for my $interface (@{$router->{interfaces}}) {
	my $network = $interface->{network};
	next if $network->{master};
	next if $network->{ip} eq 'tunnel';
	next if $duplicate{$network};
	$duplicate{$network} = 1;
	my $net_name = $network->{new_name};
	print "link $name $net_name";
    }
}
sub check_element {
    my($element) = @_;
    $element->{new_name} or die "Missing new_name in $element->{name}";
}

# Get solsoft names of netspoc objects.
sub get_element_names {
    my($elements, $context) = @_;
    my @result;
    for my $element (@$elements) {
	if(is_network $element || is_host $element) {
	    $element = $element->{master} if $element->{master};
	    push @result, $element->{new_name};
	    check_element($element);
	}

	# Convert all interfaces to 'auto' interfaces.
	# 'All' interfaces can be switched on later per solsoft rule.
	elsif(is_interface $element) {
	    push @result, $element->{router}->{new_name};
	    check_element($element->{router});
	}
	elsif(is_autointerface $element) {
	    my $object = $element->{object};
	    my $selector = $element->{selector};
	    if(is_router $object and $selector eq 'front') {
		push @result, $object->{new_name};
		check_element($object);
	    }
	    else {
		print STDERR "Ignoring $element->{name} in $context";
	    }
	}
	elsif(is_any $element) {
	    print STDERR "Ignoring $element->{name} in $context";
	}
	else {
	    die "Unexpected $element->{name} in $context\n";
	}
    }
    my %unique;
    @result = grep { not $unique{$_}++ } @result;
    return @result;
}

# Elements of groups are still textual: [ type, name, extension].
# Find groups, which reference other groups,
# because expand_group expands recursively, but we need the individual groups.
for my $group (@groups) {
    my $elements = $group->{elements};
    my @sub_groups;
    my @non_groups;
    for my $parts (@$elements) {
        my ($type, $name) = @$parts;
	if($type eq 'group') {
	    my $group = $groups{$name} or
		die "Unknown $type:$name\n";
	    push @sub_groups, $group;
	}
	else {

	    # Dont't call expand_group here, 
	    # because it would expand sub groups as well.
	    push @non_groups, $parts;
	}
    }
    $group->{sub_groups} = \@sub_groups;
    $group->{non_groups} = \@non_groups;
}

sub print_group {
    my($group) = @_;

    my %addr;
    my @elements = get_element_names($group->{non_groups}, $group->{name});
    push @elements, map { $_->{new_name} } @{$group->{sub_groups}};

    my $name = $group->{new_name};
    my $addr = join ',', @elements;
    $addr ||= 'void';
    print "class $name $addr";
}

# Print groups in such order, that referenced groups already
# have been printed.
my @current = @groups;
while(@current) {

    # Collect groups which have references to groups which have not been printed.
    my @rest;
    for my $group (@current) {
	my $ready = 1;
	for my $sub (@{$group->{sub_groups}}) {
	    if(not $sub->{ready}) {
		$ready = 0;
		last;
	    }
	}

	# Group has subgroups which have not already been printed.
	if(not $ready) {
	    push @rest, $group;
	    next;
	}

	$group->{non_groups} = 
	    Netspoc::expand_group($group->{non_groups}, $group->{name}) ;
	print_group($group);
	$group->{ready} = 1;	
    }
    @current = @rest;
}

# Find used service in servicegroups.
for my $sgroup (@servicegroups) {
    my $elements = $sgroup->{elements};
    my @non_groups;
    my @sub_groups;
    for my $element (@$elements) {
	my ($type, $name) = @$element;
	if ($type eq 'service') {
	    if (my $srv = $services{$name}) {
		$srv->{is_used} = 1;
		push @non_groups, $srv;
	    }
	    else {
		die "Can't resolve reference to '$type:$name'";
	    }
	}
	elsif($type eq 'servicegroup') {
	    my $group = $servicegroups{$name} or
		die "Unknown $type:$name\n";
	    push @sub_groups, $group;
	}
    }
    $sgroup->{sub_groups} = \@sub_groups;
    $sgroup->{non_groups} = \@non_groups;
}

sub split_obj {
    my($elements, $context) = @_;
    my @sub_groups;
    my @non_groups;
    my $user;
    for my $parts (@$elements) {
        my ($type, $name, $ext) = @$parts;
	if($type eq 'group') {
	    my $group = $groups{$name} or
		die "Unknown $type:$name\n";
	    push @sub_groups, $group;
	}
	elsif($type eq 'user') {
	    $user = 1;
	}
	else {
	    push @non_groups, $parts;
	}
    }  
    my $expanded = Netspoc::expand_group(\@non_groups, $context);
    die "Must not use 'user' together with other elements in $context" 
	if $user and (@sub_groups + @$expanded);
    return(\@sub_groups, $expanded, $user);
}

# Get a list of unresolved netspoc elements.
# Convert them to a list of names.
# If List > 1, create a new group.
# Return the new_name of the element or the string 'user'.
sub convert_elements {
    my($elements, $context) = @_;
    my ($sub_groups, $non_groups, $user) = split_obj($elements, $context);
    return('user') if $user;
    if(@$non_groups + @$sub_groups > 1) {
	my $new_name = get_name(':auto_group');
	my $new_group = Netspoc::new('Group', 
				     name => "group:$new_name",
				     new_name => $new_name, 
				     non_groups => $non_groups,
				     sub_groups => $sub_groups);
	print_group($new_group);
	return $new_group;
    } 
    return ($sub_groups->[0] || $non_groups->[0]);
}

# Automatically generate servicegroup if multiple services are referenced 
# in a single rule.
# Prevent duplicate groups with the same elements.
my %auto_sgroup;

# Find used services in policies.
# Resolve names.
# Generate servigroups and groups, if more then one element.
for my $policy (@policies) {
    my $name = $policy->{name};
    $policy->{user} = convert_elements($policy->{user}, "user of $name");
    my $rules = $policy->{rules};
    for my $rule (@$rules) {
	$rule->{src} = convert_elements($rule->{src}, "src of $name");
	$rule->{dst} = convert_elements($rule->{dst}, "dst of $name");
	my $srv_aref = $rule->{srv};
	my @non_groups;
	my @sub_groups;
	for my $pair (@$srv_aref) {
	    my ($type, $name) = @$pair;
	    if ($type eq 'service') {
		if (my $srv = $services{$name}) {
		    $srv->{is_used} = 1;
		    push @non_groups, $srv;
		}
		else {
		    die "Can't resolve reference to '$type:$name'";
		}
	    }
	    elsif($type eq 'servicegroup') {
		if (my $sgroup = $servicegroups{$name}) {
		    push @sub_groups, $sgroup;
		}
		else {
		    die "Can't resolve reference to '$type:$name'";
		}
	    }
	}
	my $count = @non_groups + @sub_groups;
	if($count  == 1) {
	    $rule->{srv} = $non_groups[0] || $sub_groups[0];
	}
	elsif($count > 1) {
	    my $key = join ',', sort map { $_->{new_name} } @non_groups, @sub_groups;
	    if(my $sgroup = $auto_sgroup{$key}) {
		$rule->{srv} = $sgroup; 
	    }
	    else {
		my $new_name = get_name(':auto_srv');
		my $new_group = Netspoc::new('Servicegroup', 
					     new_name => $new_name,
					     sub_groups => \@sub_groups,
					     non_groups => \@non_groups,
					     );
		$rule->{srv} = $new_group; 
		push @servicegroups, $new_group;
	    }
	}
    }    
}
	
for my $srv (@services) {
    next if not $srv->{is_used};
    my $name = $srv->{new_name};
    my $proto = $srv->{proto};
    my $service_elt;
    if ($proto eq 'tcp' or $proto eq 'udp') {
	my @result;
        for my $where ('src_range', 'dst_range') {

            # An array with low and high port.
            my $range  = $srv->{$where};
	    my($l, $h) = @$range;
	    if($l == 1 && $h == 65535) {
		push @result, 'ALL';
	    }
	    elsif($l == 1024 && $h == 65535) {
		push @result, 'UNP';
	    }
	    elsif($l == $h) {
		push @result, $l;
	    }
	    else {
		push @result, "$l-$h";
	    }	
        }
	my ($l, $h) = @result;
	my $direction = $srv->{oneway} ? '->' : "=>";
	$service_elt = "$proto($l $direction $h)";
    }
    elsif ($proto eq 'icmp') {
        my $type = $srv->{type};
        my $code = $srv->{code};
	if($type) {
	    $service_elt = "$proto(-> $type)";	
	}
	else {
	    $service_elt = "$proto";
	}
    }
    elsif ($proto eq 'ip') {
	$service_elt = 'ip';
    }
    else {

        # Other protocol.
        my $key = $proto;
	$service_elt = "ip(-> $proto)";
    }
    print "protocol $name $service_elt";
}

sub print_sgroup {    
    my($sgroup) = @_;
    my $name = $sgroup->{new_name};
    my @elements = (@{$sgroup->{non_groups}}, @{$sgroup->{sub_groups}});
    my $addr = join ',', map { $_->{new_name} } @elements;
    print "protocol $name $addr";
}
 
# Print servicegroups in such order, that referenced groups already
# have been printed.
@current = @servicegroups;
while(@current) {

    # Collect groups which have references to groups which have not been printed.
    my @rest;
    for my $sgroup (@current) {
	my $ready = 1;
	for my $sub (@{$sgroup->{sub_groups}}) {
	    if(not $sub->{ready}) {
		$ready = 0;
		last;
	    }
	}

	# Group has subgroups which have not already been printed.
	if(not $ready) {
	    push @rest, $sgroup;
	    next;
	}

	print_sgroup($sgroup);
	$sgroup->{ready} = 1;	
    }
    @current = @rest;
}

sub get_elt_name {
    my ($element) = @_;
    if(is_group $element) {
	$element->{new_name};
    }
    else {
	(get_element_names([$element], 'policy'))[0];
    }
}

for my $policy (@policies) {
    my $name = $policy->{name};
    my $foreach = $policy->{foreach};
    if($foreach) {
	print STDERR "Ignoring $name with 'foreach'";
	next;
    }
    my $user = $policy->{user};
    die "User of $name must not reference 'user'\n" if $user eq 'user';

    for my $rule (@{ $policy->{rules} }) {
        my $action = $rule->{action} eq 'permit' ? 'allow' : 'deny';
	my $srv_name = $rule->{srv}->{new_name};
	my $src = $rule->{src};
	my $dst = $rule->{dst};

	$src = $user if $src eq 'user';
	$dst = $user if $dst eq 'user';
	$src = get_elt_name($src);
	$dst = get_elt_name($dst);

	my $note = (split(':', $name))[1];
	# param (itf= Default | all | relevant)
	if(!$src) { print STDERR "no src in $name"; next; }
	if(!$dst) { print STDERR "no dst in $name"; next; }
	print "$action $srv_name $src - $dst param(note=\"$note\")";
    }
}

print 'aggregate /steik40xn1',
    ' "network:steik40an1","steik40an1_GRE" type(frontier)';
print 'aggregate /FHH_net',
    ' "nakahhhr01","sidzsh" type(frontier)';
print 'aggregate /FHH_net2',
    ' "network:lit_cloud","sipixhausa" type(frontier)';
print 'aggregate /FHH_net3',
    ' "FHH_Hamburg_Kopplung_Daten","sidzsh" type(frontier)';

{
    my %unique;
    @redundancy_interfaces = 
	grep { not $unique{$_}++ } @redundancy_interfaces;
}

my $zone_counter = 1; 
for my $interfaces (@redundancy_interfaces) {
    my @routers = map { $_->{router} } @$interfaces;
    my $elements = join',', map { $_->{new_name} } @routers;
    print "aggregate /zone$zone_counter",
    " $elements type(frontier)";
    $zone_counter++;
}


print "class Test_Arne/\"SCM Designer\" 10.1.0.29";
print "class Test_Arne/\"SCM Server\" 10.1.0.29";

print "# the end";

