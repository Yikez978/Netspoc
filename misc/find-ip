#!/usr/bin/perl
# find-ip
#
# Reads a list of IP addresses.
# Prints information, how these addresses are related to
# networks, hosts and interfaces of NetSPoC.
#
# Uses module Netspoc.pm,
# a Network Security Policy Compiler
# http://netspoc.berlios.de
# (c) 2009 by Heinz Knutzen <heinzknutzen@users.berlios.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

use strict;
use warnings;
use FindBin;
use lib $FindBin::Bin;
use Netspoc;
use locale;

####################################################################
# Argument processing
####################################################################
sub usage() {
    die "Usage: $0 [-n net-name ] {in-file | in-directory} [ip-list-file]\n";
}

####################################################################
# Argument to read_file; reads ip, ip-ip or ip/prefixlen
# Each address is stored as an anonymous hash, 
# thus we can add additional attributes later.
####################################################################
my @objects;
sub read_ip_stream() {
    my $ip = read_ip();
    my $object = { ip => $ip };
    if (Netspoc::check('-')) {
	my $ip2 = read_ip();
	$ip < $ip2 or 
	    err_msg "Illegal range: ", print_ip $ip, '-', print_ip $ip2;
	$object->{ip} = $ip;
	$object->{ip2} = $ip2 ;
	$object->{orig} = print_ip($ip).'-'.print_ip($ip2);
    }
    elsif(Netspoc::check('/')) {
	my $prefixlen = Netspoc::read_int();
	my $mask = Netspoc::prefix2mask($prefixlen);
	$object->{ip} = $ip;
	$object->{mask} = $mask;
	$object->{orig} = print_ip($ip)."/$prefixlen";
    }
    else {
	$object->{ip} = $ip;
	$object->{orig} = print_ip($ip);
    }
    push @objects, $object;
}


####################################################################
# Prepare efficient lookup of network objects.
####################################################################

my $nat_map;
my %mask_ip_hash;
my %host_hash;
my %range_hash;
sub prepare() {
    for my $network (values %networks) {
	next if $network->{ip} =~ /^(unnumbered|tunnel)$/;
	next if $network->{disabled};
	$network = $nat_map->{$network} || $network;
	if(my $old_net = $mask_ip_hash{$network->{mask}}->{$network->{ip}}) {
	    err_msg "$network->{name} and $old_net->{name} have identical ip/mask";
	}
	$mask_ip_hash{$network->{mask}}->{$network->{ip}} = $network;
    }
    my @ranges;
    for my $host (values %hosts) {
	if(my $ips = $host->{ips}) {
	    $host_hash{$ips->[0]} = $host;
	    if(@$ips > 1) {
		Netspoc::warn_msg 
		    "Ignoring other IP addresses of $host->{name}";
	    }
	} elsif(my $range = $host->{range}) {
	    my($i1, $i2) = @$range;
	    $range_hash{$i1}->{$i2} = $host;
	} else {
	    die "$host->{name} has neither IP nor range\n";
	}
    }
    for my $interface (values %interfaces) {
	next if $interface->{disabled};
	my $ip = $interface->{ip};
	next if $ip =~ /^(unnumbered|short|negotiated|tunnel)$/;
	$host_hash{$ip} = $interface;
    }
}

my @unknown;
sub check_subnet( $ ) {
    my $obj = shift;
    my $ip = $obj->{ip};
    my $ip2 = $obj->{ip2};
    my $mask = $obj->{mask};
    if(defined $mask) {
	if(my $ip_hash = $mask_ip_hash{$mask}) {
	    if(my $net = $ip_hash->{$ip}) {
		$obj->{name} = $net->{name};
	    }
	}
    }
    elsif(defined $ip2) {
	if(my $ip2_hash = $range_hash{$ip}) {
	    if(my $host = $ip2_hash->{$ip2}) {
		$obj->{name} = $host->{name};
	    }
	}		
    }
    elsif(my $host = $host_hash{$ip}) {
	$obj->{name} = $host->{name};
    }
    return if $obj->{name};

    # Find network of unknown objects.
    my $m = $mask || 2**32-1;
    my $i = $ip;
    while($m) {
	$i &= $m;
	if(my $ip_hash = $mask_ip_hash{$m}) {
	    if(my $net = $ip_hash->{$i}) {
		if($ip2 && (($ip2 & $m) != $i)) {
		}
		else {
		    $obj->{network} = $net;
		    return;
		}
	    }
	}
	# Clear upper bit, because left shift is undefined otherwise.
	$m &= 0x7fffffff;
	$m <<= 1;
    }
    push @unknown, $obj;
}

####################################################################
# Main program
####################################################################

my $nat_net;
if($ARGV[0] eq '-n') {
    shift;
    $nat_net = shift or usage;
}

my $config = shift @ARGV or usage;

# Read and process Netspoc configuration file or directory.
&read_file_or_dir($config);
&link_topology();
&mark_disabled();
&distribute_nat_info();

if($nat_net) {
    my $net = $networks{$nat_net} or 
	err_msg "Unknown network:$nat_net of option '-n'";
    $nat_map = $net->{nat_domain}->{nat_map};
}

# read from file or STDIN
my $file = shift || '-';
# read a space separated list of ip addresses
# Undef input record separator.
local $/;
&read_file($file, \&read_ip_stream);
# prepare efficient lookup of network objects from netspoc policy
&prepare();

# link ip addresses with network objects
for my $obj (@objects) {
    check_subnet $obj;
}

# Print result.
for my $obj (sort { $a->{ip} <=> $b->{ip} } @objects) {
    if(my $name = $obj->{name}) {
	print "   $name\t\t$obj->{orig}\n";
    }
    elsif(my $network = $obj->{network}) {
	print "in $network->{name}\t\t$obj->{orig}\n";
    }
}
for my $obj (@unknown) {
    print "unknown\t\t$obj->{orig}\n";
}

