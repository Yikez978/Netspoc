#!/usr/bin/perl
# rename-netspoc
# 
#
# http://netspoc.berlios.de
# (c) 2011 by Heinz Knutzen <heinzknutzen@users.berlios.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# $Id$
 
use strict;
use warnings;
use open qw(:std :utf8);
use utf8;
use Encode;
my $filename_encode = 'UTF-8';
 
my $ignore_files = '^(raw|config|CVS|RCS|\.#.*|.*~)$';
 
####################################################################
# Argument processing
####################################################################
sub usage() {
    die "Usage: $0 {in-file | in-directory} TYPE:OLD-NAME TYPE:NEW-NAME ...\n";
}
 
sub debug { print STDERR @_, "\n"; }
sub info  { print STDERR @_, "\n"; }
 
sub fatal_err( @ ) {
    print STDERR "Error: ", @_, "\n";
    die "Aborted\n";
}

my %global_type = 
    map { $_ => 1 } qw( 
router network host any group area policy
owner admin service servicegroup pathrestriction nat isakmp ipsec crypto 
);

# NAT is applied with bind_nat.
# Admin attribute is named "admins" in definition of owner.
my %aliases = ( nat => 'bind_nat', admin => 'admins' );

my %subst;

# Fill %subst with arrays of search/replace pairs for given type.
sub setup_subst {
    my ($type, $search, $replace) = @_;
    $global_type{$type} or fatal_err("Unknown type $type");

    # Quote pattern metacharacters.
    $search = qr/\Q$search\E/;

    # Escape perl sigils in replace string, because we apply eval on it.
    $replace =~ s/([@%\$])/\\$1/g;

    # Standard for all types.
    push @{ $subst{$type} }, [qr/$search/, $replace];

    # Network name occurs in interface name and in id: hosts.
    if ($type eq 'network') {

        # Definition of interface inside definition of router.
        push(@{ $subst{interface} }, [ qr/$search/, $replace ]);

        # Reference to interface ouside of definition of router.
        push(@{ $subst{interface} },
             [ qr/([\w@-]+\.)$search(\..*)?/, '$1'.$replace.'$2' ]);
        push(@{ $subst{host} },
             [ qr/(id:.*\.)$search/, '$1'.$replace ]);
    }

    # Router name occurs in interface name.
    elsif ($type eq 'router') {
        push(@{ $subst{interface} }, [ qr/$search([.@].*)/, $replace.'$1' ]);
    }

    # Name of id: host is extended with some network name.
    elsif ($type eq 'host') {
        push(@{ $subst{host} }, [ qr/$search([.][\w-]+)/, $replace.'$1' ]);
    }

    elsif (my $other = $aliases{$type}) {
         push @{ $subst{$other} }, [qr/$search/, $replace];
    }
}
 
sub subst {
    my ($type, $name) = @_;
    my $aref = $subst{$type} or return $name;
    for my $pair (@$aref) {
        my ($search, $replace) = @$pair;
        if ($name =~ /^$search$/) {
            
            # Eval special variables $1, $2, .. inside $replace.
            # Optional captures may be undefined.
            no warnings 'uninitialized';
            $name = eval("\"$replace\"");
        }
    }
    return $name;
}

sub process {
    my ($lines) = @_;
    my $changed = 0;
    my $type_list;
    for my $line (@$lines) {
        my $copy = '';
        my $line_changed = 0;
      TOKEN:
        while(1) {

            # Handle list of names 
            # - after "name = "
            # - and on new line.
            if ($type_list) {
              LIST:
                while (1) {

                    # Read list element.
                    if ($line =~ /\G (\s*) ([-\w.\@:]+) /gcx) {
                        $copy .= $1;
                        my $name = $2;
                        my $new = subst($type_list, $name);
                        $copy .= $new;
                        $line_changed++ if $name ne $new;
                    }

                    # Read comma.
                    elsif ($line =~ /\G (\s*,\s*) /gcx) {
                        $copy .= $1;
                    }
                    else {
                        last LIST;
                    }                    
                }

                # Whitespace or comment at end of line doesn't terminate list.
                if ($line =~ /\G (\s* (?:[#].*)? ) $/gcx) {
                    $copy .= $1;
                    last TOKEN;
                }

                # Everything else terminates list.
                else {
                    $type_list = undef;
                }
            }

            # Find next "type:name" or "type = name".
            elsif ($line =~ /\G (.*?) (\w+) (:|\s*=\s*) /gcx) {
                $copy .= "$1$2$3";
                my $type = $2;
                next if not $subst{$type};
                next if $type_list = ($3 eq ':') ? undef : $type;
                $line =~ /\G  ([-\w.\@:]+) /gcx or next;
                my $name = $1;
                my $new = subst($type, $name);
                $copy .= $new;
                $line_changed++ if $name ne $new;
            }

            # Ignore rest of line of nothing matches.
            else {
                $line =~ /\G (.+) /gcsx and $copy .= $1;
                last TOKEN;
            }
        }
        if ($line_changed) {
            $line = $copy;
            $changed += $line_changed;
        }
    }
    return $changed;
}
 
sub process_file {
    my ($path) = @_;
#    debug "File $path";
    open(my $file, '<', $path) or fatal_err "Can't open $path: $!";
    my @input = <$file>;
    close $file;
    if (my $count = process(\@input)) {
        info "$count changes in $path";
        unlink($path) or fatal_err "Can't remove $path: $!\n";
        open($file, '>', $path) or fatal_err "Can't create $path: $!";
        print $file @input;
        close $file;
    }
}
 
sub process_file_or_dir {
    my ($path) = @_;
    if (-d $path) {
        local (*DIR);
 
        # Strip trailing slash.
        $path =~ s</$><>;
        opendir DIR, $path or fatal_err "Can't opendir $path: $!";
        while (my $file = Encode::decode($filename_encode, readdir DIR)) {
            next if $file eq '.' or $file eq '..';
            next if $file =~ m/$ignore_files/;
            $file = "$path/$file";
            process_file_or_dir($file);
        }
        closedir DIR;
    }
    else {
        process_file($path);
    }
}

####################################################################
# Main program
####################################################################
 
my $path = shift @ARGV or usage;

# Process search/replace pairs.
@ARGV or usage();
while (@ARGV) {
    my $old = shift @ARGV;
    my $new = shift @ARGV or fatal_err "Missing replace string for '$old'";
    my ($type, $old_name) = ($old =~ /^(\w+):(.*)$/) or usage();
    my ($n_type, $new_name) = ($new =~ /^(\w+):(.*)$/) or usage();
    $type eq $n_type or 
        fatal_err "Types '$type' and '$n_type' must be identical";
    setup_subst($type, $old_name, $new_name);
}
process_file_or_dir($path);
