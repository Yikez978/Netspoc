#!/usr/bin/perl
# rename-netspoc
#
#
# http://netspoc.berlios.de
# (c) 2011 by Heinz Knutzen <heinzknutzen@users.berlios.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# $Id$
 
use strict;
use warnings;
use open qw(:std :utf8);
use utf8;
use Encode;
my $filename_encode = 'UTF-8';
 
my $ignore_files = '^(raw|config|CVS|RCS|\.#.*|.*~)$';
 
####################################################################
# Argument processing
####################################################################
sub usage() {
    die "Usage: $0 {in-file | in-directory} type old-name new-name\n";
}
 
sub debug ( @ ) {
    print STDERR @_, "\n";
}
 
sub fatal_err( @ ) {
    print STDERR "Error: ", @_, "\n";
    die "Aborted\n";
}
 
# Extension for te
my $backup_extension = '.#bak';
 
####################################################################
# Main program
####################################################################
 
my %subst;
 
my %global_type = (
                                  router          => 1,
                                  network         => 1,
                                  any             => 1,
                                  area            => 1,
                                  owner           => 1,
                                  admin           => 1,
                                  group           => 1,
                                  service         => 1,
                                  servicegroup    => 1,
                                  policy          => 1,
                                  pathrestriction => 1,
                                  nat             => 1,
                                  isakmp          => 1,
                                  ipsec           => 1,
                                  crypto          => 1,
                                  host            => 1,
                                  );
 
sub setup_subst {
    my ($type, $search, $replace) = @_;
    $global_type{$type} or fatal_err("Unknown type $type");
    $search =~ /^[\w-]+$/ or fatal_err "Illagal search string";
    $replace =~ /^[\w-]+$/ or fatal_err "Illagal replace string";
    push @{ $subst{$type} }, [$search, $replace];
    if ($type eq 'network') {
        push(@{ $subst{interface} },
             [ qr/([\w@-]+\.)$search(.*)?/, '$1'.$replace.'$2' ]);
        push(@{ $subst{host} },
             [ qr/(.*\.)$search/, '$1'.$replace ]);
    }
    elsif ($type eq 'router') {
        push(@{ $subst{interface} }, [ qr/$search([.@].*)/, $replace.'$1' ]);
    }
    elsif ($type eq 'nat') {
        $subst{bind_nat} = $subst{nat};
    }
    elsif ($type eq 'admin') {
        $subst{admins} = $subst{admin};
    }
}
 
sub subst {
    my ($type, $name) = @_;
    my $aref = $subst{$type} or return;
    for my $pair (@$aref) {
                my ($search, $replace) = @$pair;
                if ($name =~ /^$search$/) {
 
                    # Eval $1, .. inside $replace.
                    return eval("\"$replace\"");
                }
    }
    return undef;
}
 
sub subst_list {
    my ($type, $list) = @_;
    my $changed;
 
    # Remove spaces.
    $list =~ s/\s*//g;
 
    # Split at comma.
    my @names = grep { $_ !~ /^$/ } split(/,/, $list);
    my @new;
    for my $name (@names) {
                if (my $new = subst($type, $name)) {
                    $changed = 1;
                    push @new, $new;
                } else {
                    push @new, $name;
                }
    }
    return $changed ? join(', ', @new) : undef;
}
   
sub process {
    my ($lines) = @_;
    my $changed;
    for my $line (@$lines) {
        my $copy = '';
        my $line_changed;

        my $subst_list = sub {
            my ($type) = @_;
            while (1) {

                # Read list element ", name".
                if ($line =~ /\G (\s*,\s*) ([-\w.\@:]+) /gcx) {
                    $copy .= $1;
                    my $name = $2;
                    if (my $new = subst($type, $name)) {
                        $copy .= $new;
                        $line_changed = 1;
                    }
                    else {
                        $copy .= $name;
                    }
                }
                else {
                    last;
                }                    
            }
        };

        my $in_list;
        while(1) {

            if (my $type = $in_list) {
                $subs_list->($type);
                if (/\G (#.*) /gcx) {
                    $copy .= $1;
                    $line = $copy;
                    last;
                }
            # Find next "type:name" or "type = name"
            if ($line =~ /\G (.*?) (\w+) (:|\s*=\s*) ([-\w.\@:]+) /gcx) {
                $copy .= "$1$2$3";
                my $type = $2;
                my $is_list = ($3 ne ':');
                my $name = $4;
                if (my $new = subst($2, $name)) {
                    $copy .= $new;
                    $line_changed = 1;
                }
                else {
                    $copy .= $name;
                }
                if ($is_list) {
                    $in_list = $type;
                }
            }

            # type:name
            if ($line =~ /\G (.*?) ([a-z]+) (:) ([-\w.\@:]+)/gcx) {
                $copy .= "$1$2$3";
                my $name = $4;
                if (my $new = subst($2, $name)) {
                    $copy .= $new;
                    $line_changed = 1;
                }
                else {
                    $copy .= $name;
                }
            }

            # owner = name
            elsif ($line =~ 
                   /\G (.*?) (admins|bind_nat|owner) (\s*=\s*) ([^;]+)/gcx) 
            {
                $copy .= "$1$2$3";
                my $list = $4;
                if (my $new = subst_list($2, $list)) {
                    $copy .= $new;
                    $line_changed = 1;
                }
                else {
                    $copy .= $list;
                }
            }
            elsif (not $line_changed) {
                last;
            }
            else {
                $copy .= substr($line, pos($line));
                $line = $copy;
                last;
            }
        }
        $changed ||= $line_changed;
    }
    return $changed;
}
 
sub process_file {
    my ($path) = @_;
    debug "File $path";
    open(my $file, '<', $path) or fatal_err "Can't open $path: $!";
    my @input = <$file>;
    close $file;
    if (process(\@input)) {
                my $backup = "$path.$backup_extension";
                unlink($path) or fatal_err "can't remove $path: $!\n";
                open($file, '>', $path) or fatal_err "Can't create $path: $!";
                print $file @input;
                close $file;
    }
}
 
sub process_file_or_dir {
    my ($path) = @_;
    if (-d $path) {
        local (*DIR);
 
        # Strip trailing slash.
        $path =~ s</$><>;
        opendir DIR, $path or fatal_err "Can't opendir $path: $!";
        while (my $file = Encode::decode($filename_encode, readdir DIR)) {
            next if $file eq '.' or $file eq '..';
            next if $file =~ m/$ignore_files/;
            $file = "$path/$file";
            process_file_or_dir($file);
        }
        closedir DIR;
    }
    else {
        process_file($path);
    }
}
 
 
my $path = shift @ARGV or usage;
my $type = shift @ARGV or usage;
my $search = shift @ARGV or usage;
my $replace = shift @ARGV or usage;
setup_subst($type, $search, $replace);
process_file_or_dir($path);
