#!/usr/bin/perl
# cut-netspoc
# Print parts of a netspoc configuration to stdout.
# http://netspoc.berlios.de
# (c) 2005 by Heinz Knutzen <heinzknutzen@users.berlios.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

use strict;
use warnings;
use FindBin;
use lib $FindBin::Bin;
use Netspoc;

####################################################################
# Argument processing
####################################################################
sub usage() {
    die "Usage: $0 {in-file | in-directory} policy:name ...\n";
}

# Enhanced version of read_netspoc, which stores source code of each
# global definition.
sub read_netspoc_with_src () {
    my $pre = pos;
    my $object = &read_netspoc();
    my $post = pos;
    $object->{src_code} = substr $_, $pre, $post - $pre;
#    print STDERR "$object->{name} $pre-$post\n";
    return $object;
}

# This function is called by path_walk to mark all networks and routers
# on path from src to dst of $rule with attribute {is_used}.
sub mark_topology( $$$ ) {
    my ($rule, $in_intf, $out_intf) = @_;
    my $router = ($in_intf || $out_intf)->{router};
    $router->{is_used} = 1;
    # Not only networks on path, but all connected networks need to be marked
    # to get a valid topology.
    for my $interface (@{$router->{interfaces}}) {
	$interface->{network}->{is_used} = 1;
    }
}

####################################################################
# Main program
####################################################################

my $config = shift @ARGV or usage;
&show_version();

# Read and process netspoc policy.
# Remember source code of each global definition.
&read_file_or_dir($config, \&read_netspoc_with_src);

# Read names of policies from command line.
for my $arg (@ARGV) {
    my($type, $name) = split_typed_name $arg;
    $type eq 'policy' or usage;
    my $policy = $policies{$name} or die "Unknown $arg\n";
    $policy->{is_used} = 1;
}

# Delete unwanted policies.
for my $name (keys %policies) {
    unless($policies{$name}->{is_used}) {
	delete $policies{$name};
    }
}

&link_topology();
&mark_disabled();
&setany();
&setpath();
&expand_policies();
die "Aborted with $error_counter error(s)\n" if $error_counter;

# Mark parts of topology which are referenced by rules of policies.
for my $type ('deny', 'any', 'permit') {
    for my $rule (@{$expanded_rules{$type}}) {
	for my $where ('src', 'dst') {
	    # path_walk only handles networks and routes, 
	    # therefore 'any' objects need to be marked separately.
	    is_any $rule->{$where} and $rule->{$where}->{is_used} = 1;
	}
	&path_walk($rule, \&mark_topology);
	$rule->{srv}->{is_used} = 1;
    }
}

# Mark interfaces which are referenced by areas.
for my $area (values %areas) {
    if($area->{is_used}) {
	if(my $anchor = $area->{anchor}) {
	    $anchor->{is_used} = 1;
	} else {
	    for my $interface (@{$area->{border}}) {
		mark_topology undef, $interface, undef;
	    }
	}
    }
}

# Print marked parts of netspoc configuration.
# Routers and networks have been marked by mark_topology.
# Services have been marked while %expanded_rules have been processed above.
# Groups, servicegroups and 'every' objects have been marked 
# during expand_policies.
delete $anys{'[local]'};
for my $object (values %routers, values %networks,
		values %anys, values %everys, values %areas, values %groups,
		values %services, values %servicegroups) {
    if($object->{is_used}) {
	# There are some internal objects without src_code.
	if(my $src_code = $object->{src_code}) {
	    print $src_code, "\n";
	}
    }
}

# Source of pathrestrictions can't be used literally, 
# but must be reconstructed from internal data structure. 
for my $restrict (values %pathrestrictions) {
    my $used = 0;
    for my $interface (@{$restrict->{elements}}) {
	if($interface->{router}->{is_used}) {
	    $used++;
	} else {
	    $interface = undef;
	}
    }
    next if $used < 2;
    print "$restrict->{name} =\n";
    for my $interface (@{$restrict->{elements}}) {
	next unless $interface;
	print " $interface->{name},\n";
    }
    print ";\n";
}

# Find global NAT definitions which are bound by used interfaces.
if(keys %global_nat) {
    my %used_nat;
    for my $interface (values %interfaces) {
	$interface->{router}->{is_used} or next;
	my $nat_tag = $interface->{bind_nat} or next;
	$used_nat{$nat_tag} = 1;
    }
    for my $nat_tag (keys %global_nat) {
	next unless $used_nat{$nat_tag};
	print $global_nat{$nat_tag}->{src_code}, "\n";
    }
}	

# All unwanted policies have already been deleted above.
for my $policy (values %policies) {
    print $policy->{src_code}, "\n";
}
