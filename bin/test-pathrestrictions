#!/usr/bin/perl

use strict;
use warnings;
use Netspoc;
use open qw(:std :utf8); #meike: check das mal.

##############################################################################
# Purpose : Read next definition from input. 
# Comment : This function is a modification of Netspoc::read_netspoc that skips
#           rule related information. 
my $read = sub {

    # Check for global definitions.
    my $pair = Netspoc::check_typed_name or Netspoc::syntax_err('');
    my ($type, $name) = @$pair;
    print "$type\n";
    # Skip service declarations.
    if ($type eq "service") {
        while (1) { # Adjust input position.
            last if Netspoc::check '\}';
            Netspoc::skip('.*');
        }
        return;
    }
    # Skip group/protocol/protocolgroup declarations.TODO: erwischt nicht alle.
    if ($type eq "group" || $type eq "protocolgroup" || $type eq "protocol") {
        while (1) { # Adjust input position.
            last if Netspoc::check '.*;';
            Netspoc::skip('.*');
        }
        return;
    }

    my $descr = $Netspoc::global_type{$type}
      or Netspoc::syntax_err("Unknown global definition");
    my ($fun, $hash) = @$descr;
    my $result = $fun->("$type:$name");
    $result->{file} = $Netspoc::current_file;
    if (my $other = $hash->{$name}) {
        err_msg("Duplicate definition of $type:$name in",
                " $Netspoc::current_file and $other->{file}");
    }
    return $hash->{$name} = $result;
};

##############################################################################
# Main

# Get input file.
if (@ARGV != 1) {
    print "Usage:\n" .
        "\ttest-pathrestrictions FILE|DIR\n\n";
    exit;
}
my ($in_path) = @ARGV;

# Process required netspoc steps.
#my $file_config = &read_config($in_path);
#&set_config($file_config, { verbose => "quiet" });

&read_file_or_dir($in_path, $read);#skip rule related infos
&show_read_statistics;
&link_topology();
&mark_disabled();
&set_zone();
&distribute_nat_info();#TODO: do i need this?

Netspoc::find_dists_and_loops();
Netspoc::process_loops();
Netspoc::check_pathrestrictions();

Netspoc::optimize_pathrestrictions();

my $defined = keys %Netspoc::pathrestrictions;
my $applied = @Netspoc::pathrestrictions;

print "$defined pathrestriction(s) defined.\n";
print "$applied pathrestriction(s) applied.\n";
print "Optimization failed at:\n";

for my $restriction (@Netspoc::pathrestrictions) {
    my $fail = 0;
    for my $interface (@ {$restriction->{elements}} ) {
         if ($interface->{path_restrict}) {
            $fail = grep {$_ == $restriction} 
                              @{$interface->{path_restrict}};
        }
        if ($fail > 0) {
             last;
        }
    }
    if ($fail > 0) {
        print "  $restriction->{name}\n";
    }
}
# Interessant wäre zu wissen, an welchen Pathrestrictions es liegt,
# aber an diese Information komme ich nicht ran: für Interfaces, die
# innerhalb einer partition liegen wird zwar für die betreffende
# Pathrestriction kein {reachable_at} angelegt, aber es ist durchaus
# möglich, dass an dem Interface ein {reachable_a}t für eine andere
# Pathrestriction existiert. das Vorhandensein des {reachable_at} ist
# daher kein Zeichen dafür, dass das Interface optimierbar ist. Die
# Zusammenhörigkeit von partition marks und pathrestrictions, die für
# die Beantwortung der Frage notwendig wären, wird leider nirgends
# gespeichert.

#Hier besteht eventuell noch Aufräumpotential: nicht immer werden für
#ungültige Pathrestrictions auch die Markierungen an den Interfaces
#gelöscht:

# Collect all interfaces with pathrestriction.
 
#push my @restricted_interfaces, grep({ $_->{path_restrict} } 
#                                 values %Netspoc::interfaces);
#
## vergleiche die pathrestrictions an den interfaces mit denen, die valide sind:
#for my $interface (@restricted_interfaces) {
#    for my $check (@{ $interface->{path_restrict} }) {
#        my $valid = grep {$_ == $check} @Netspoc::pathrestrictions;
#        if ($valid == 0) {
#            print "pathrestriction $check->{name} is invalid\n";
#        }
#    }
#}

# das scheint allerdings in der Produktionstopologie nicht vorzukommen...
# klar, da sind ja auch keine ungültigen PRs drinne...
