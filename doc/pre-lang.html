<HTML>
<HEAD>
<!-- $Id$ -->
<TITLE>Description Language for Security Policy and Topology</TITLE>
<style type="text/css">
<!--
body { background-color:white;
       margin-left:0.5cm;
       font-family:helvetica,arial,sans-serif;  }
h1 { font-size:20pt;
     color:maroon;
     text-align:center;
     border-bottom:solid thin black; }
h1 image { border-style:none;
           padding:0cm; }
  
pre {
  border-width:thin;
  border-style:solid;
  color:blue;
  border-color:black;
  padding:0.15cm; }
tt {
  color:blue; }
code {
  color:blue; }
image {
  border-width:thin;
  border-style:solid;
  padding:0.15cm; }
dt { 
  color:blue;
  font:bold; }
-->
</style>
</HEAD>

<BODY bgcolor=#FFFFFF>

<H1>Description Language for Security Policy and Topology</H1>

<!--toc-->

<H2>Overview</H2>

<h3>Policies</h3>

<ul>
<li>A policy is a set of related rules. 
<li>Network objects and service definitions are used in rules to
describe network traffic which can or must not pass from source to
destination.
<li>All rules of a single policy must refer to the same network
objects in their source or destination.
<li>Policies have a name which can be used for documentation or
reporting purposes.
</ul>

<H3>Network Objects</H3>
<UL>
<LI>Have name and IP address.
<LI>Describe the topology.
<LI>Can be used as source and destination of rules.
</UL>

<H3>Service Definitions</H3>
<UL>
<LI>have a name
<LI>describe properties of network traffic as they typically can be
filtered by packet filters (i.e. type of protocol, port number)
</UL>

<H3>Groups</H3>
<UL>
<LI>have a name
<LI>are used to group network objects
<LI>are used in rules for simplified management of large numbers of
network objects.
</UL>

<H3>Service Groups</H3>
<UL>
<LI>
have a name
<LI>are used to group service definitions
<LI>are used in rules
</UL>

<h3>Areas</h3>

The topology is build from networks and routers. Networks and routers are
connected by interfaces. 

<p>An <em>area</em> denotes a part of the topology which is delimited by a set
of interfaces. Areas are used to access all networks or security domains of
some part of the topology.

<h3>Crypto Definition</h3>

A <a href="#crypto_syntax">crypto definition</a> consists of three parts:
<ol>
<li>A definition of crypto tunnels.
<li>A set of rules describing which traffic has to be encrypted.
<li>A reference to another definition with details about the used
encryption method. Currently only IPSec is supported.
</ol>

Crypto definitions are very powerful: A large number of crypto tunnels of
either a hub and spoke topology or a fully meshed topology can be defined
easily. 

<H2>Detailed description of network objects</H2>
<P>The topology is built from networks and routers.
A router and a network are connected by an interface.
Networks can have any number of hosts, which are located inside the
network.</P>
<P>Routers can be managed or unmanaged. For a managed router, NetSPoC
generates access control lists which control what traffic can pass
this router and what traffic is blocked.
The whole topology is partitioned into different security domains by
managed routers.</P>
<P>Special network objects called 'any' objects can
be defined which denote all network objects inside a security domain.</P>

<H3>General syntax</H3>
<P>All network objects and groups have a typed name like &lt;type&gt;:&lt;name&gt;.</P>
<P>&lt;name&gt; is build from one ore more alphanumerical characters together
with hyphen and underscore. The current locale settings are used,
i.e. accented characters are allowed for European locale settings.</P>
<P>&lt;ip-adr&gt; denotes an IP address. Currently NetSPoC handles IP v4
addresses n.n.n.n with 0 &lt;= n &lt;= 255</P>
<p>&lt;text_to_end_of_line&gt; is any text from current position up to end of
line.</p>
<P>&lt;external_name&gt; can contain almost any characters, but not
whitespace, no delimiters <CODE>[;,=]</CODE> and no quotes 
<CODE>[&quot;']</CODE>.</P> 
<P>&lt;int&gt; is an integer</P>
<P>Meta symbols in syntax definitions below:</P>
<UL>
<LI><code>&lt;xx&gt;</code> denote something defined elsewhere.
<LI><code>[[xx]]</code> denotes an optional part.
<br>Note: single [ and ] characters stand for themselves.
<LI><code>{{xx|yy}}</code> denotes alternatives.
<br>Note: single { and } characters stand for themselves.
<LI><code>xx *</code> means any number of the left part.
<li><code>xx, ...</code> means a comma separated list of one or more elements
of the left part.
</UL>

<H3><A NAME="network_definition">Network Definition</A></H3>
<H4>Syntax</H4>
<PRE>
  network:&lt;name&gt; = {
     [[ owner = &lt;external_name&gt;, ... ; ]]
     {{
         ip = &lt;ip-adr&gt;&lt;mask&gt;;
	 &lt;network NAT definition&gt; *
         [[ route_hint; ]]
	 [[ subnet_of = network:&lt;name&gt;; ]]
         &lt;host definition&gt; *
     |
         unnumbered
     }}
  }
</PRE>
with
<pre>
  &lt;network NAT definition&gt; ::=
         nat:&lt;name&gt; = { 
	  ip = &lt;ip-adr&gt;[[&lt;mask&gt;]];
	  [[ dynamic; ]]
	  [[ subnet_of = network:&lt;name&gt;; ]] 
	 }

  &lt;mask&gt; ::= {{/&lt;prefix-lenght&gt; | ; mask = &lt;ip-adr&gt; }}
  &lt;prefix-lenght&gt; ::= {{ 0 | 1 | 2 | ... | 32 }}
</pre>
<UL>
<LI>A network is described by an ip address and a mask or
<LI>can alternatively be marked as unnumbered.
<LI>It can contain any number of host definitions.
<LI>Unnumbered networks must have no host definitions at all.
<LI>If used as source or destination of a rule, the ip/mask is used
directly for generating ACLs.
<LI>An unnumbered network must not be used in rules.
<LI>All networks must be disjunct if option 'strict_subnets' is
active. Exceptions must be declared explictly:
<UL>
<LI>route_hint: This network can enclose other networks, but it must
not have host definitions.
<LI>subnet_of: The enclosing network must be stated explicitly.
</UL>
This can be useful for a large topology, where a network can easily be
redefined by mistake.
</UL>

<H3><A NAME="host_definition">Host definition</A></H3>
<H4>Syntax</H4>
<PRE>
  &lt;host definition&gt; ::=
        host:&lt;name&gt; = { 
          [[ owner = &lt;external_name&gt;, ... ; ]]  
	  {{
	    ip = &lt;ip-adr&gt;, ... ;
          |
            range = &lt;ip-adr&gt; - &lt;ip-adr&gt;;
	  }}
          &lt;NAT definition&gt; *
        }

  &lt;NAT definition&gt; ::=
        nat:&lt;name&gt; = { ip = &lt;ip-adr&gt;; }
</PRE>

<UL>
<LI>A host can only be defined inside a network definition.
<LI>It has one or more IP addresses or
<LI>alternatively an ip address range with first address &lt; second address
<LI>IP addresses must match ip/mask of the surrounding network.
<LI>If used as source or destination of a rule, one ACL entry is
generated for each IP address.
<LI>NetSPoC tries to automatically convert successive IP addresses from one
or multiple hosts of a common network to an IP range.
<LI>During code generation, an IP range is split into a number of
subnetworks which cover the range. One ACL entry is generated for
each subnetwork.
</UL>

<H3><A NAME="router_definition">Router definition</A></H3>
<H4>Syntax</H4>
<PRE>
  &lt;router definition&gt; ::=
  router:&lt;name&gt; = {
     {{
        managed [[ = {{ full | secondary }} ]] ;
        model = &lt;name&gt;;
	[[ no_group_code; ]]
	[[ no_crypto_filter; ]]
	&lt;interface definition&gt; *
     |
        [[ model = &lt;name&gt;; ]]
        {{ 
           &lt;interface definition&gt; 
        | 
           &lt;short interface definition&gt; 
        }} *
     }}
  }</PRE>
<UL>
<li>A router can be managed or unmanaged.
<li>Managed routers can be of type 'full' or of type 'secondary'. A
type 'full' is assumed, if no value is given. See <A
HREF="#secondary">secondary packet filters</A> below for a detailed
description. 
<LI>Managed routers need to be precisely described since this
 information is needed for code generation later.
<LI>The router model is used to generate correct code for different
 router models.<BR>Currently four models are supported:
<UL>
  <li><code>Linux</code> for Linux with iptables
<LI><code>ASA</code> for Cisco ASA 
<LI><code>PIX</code> for Cisco PIX 
<li><code>IOS</code> for Cisco IOS routers
<LI><code>IOS, FW</code> for Cisco IOS routers with statefull inspection
<LI><code>IOS, EZVPN</code> for Cisco IOS routers with easy VPN
</UL>
<LI>NetSPoC generates optimized code using object groups for PIX firewalls. 
Use flag <code>no_group_code</code> to disable this optimization. 
<li>For IOS routers from version 12.3(8)T up, a separate access-list is used
for filtering incoming traffic of crypto tunnels. Use
attribute <code>no_crypto_filter</code> to enable the old behavior where
crypto traffic is filtered by access-lists of interfaces.
<LI>A Router can have any number of interface definitions.
<LI>For unmanaged routers, all attributes are optional.
<li>An interface definition without attributes is called a "short
interface definition".
</UL>

<H3><A NAME="interface_definition">Interface definition</A></H3>
<H4>Syntax</H4>
<PRE>
  &lt;interface definition&gt; ::= 
    interface:&lt;name&gt; = {
         {{ ip = &lt;ip-adr&gt;, ... ; | unnumbered; | negotiated; }}
	 &lt;secondary interface definition&gt; *
	 [[ &lt;virtual interface definition&gt; ]]
         &lt;NAT definition&gt; *
         [[ &lt;NAT binding&gt; ]]
         [[ hardware = &lt;external_name&gt; ; ]]
	 [[ routing = {{ EIGRP | OSPF | manual }} ; ]]
	 [[ reroute_permit = network:&lt;name&gt;, ... ; ]]
	 [[ loopback ; ]]
         [[ disabled ; ]]
    }

  &lt;secondary interface definition&gt; ::=
    secondary:&lt;name&gt; = { 
         ip = &lt;ip-adr&gt;;
    }

  &lt;virtual interface definition&gt; ::=
    virtual = { 
         ip = &lt;ip-adr&gt;;
         type = {{ VRRP | HSRP }};
         [[ id = &lt;int&gt;; ]]
    }

  &lt;NAT definition&gt; ::=
    nat:&lt;name&gt; = { ip = &lt;ip-adr&gt;; }
  &lt;NAT binding&gt; ::=
    nat = &lt;name&gt;;

  &lt;short interface definition&gt; ::=
    interface:&lt;name&gt;;
 </PRE>

<UL>
<LI>Interfaces have no name of their own; instead a network name is used
  to indicate that the interface is linked to a network of the same
  name.
<LI>An interface can have one or more IP addresses. All of them must
  match the IP/mask of the corresponding network.
<LI>An unnumbered interface must only be linked to an unnumbered network.
<li>A negotiated interface has an unknown IP address out of the attached
  network. If an interface with negotiated IP is used in a rule, the address
  range of the attached network is used.
<li>Additional IP addresses can be defined using a secondary
  interface. A secondary interface is referenced as
  <code>interface:&lt;router-name&gt;.&lt;network-name&gt;.&lt;secondary-name&gt;</code>
<li>
  Another method to define secondary interfaces is by giving two or more IP
  addresses to the primary interface. This implicitly defines secondary
  interfaces with a name which is derived from the name of the primary
  interface by adding an incrementing number beginning with "2".
  E.g. <code>interface:router.name.2, interface:router.name.3, ...</code>.
<li>A virtual interface defines a shared IP address and type of redundancy
  protocol. See <a name="#virtual"> Virtual interfaces</a> for details.
<LI>The 'hardware' attribute indicates, which hardware interface the router
  belongs to. This attribute is mandatory for managed routers.
<LI>Multiple interfaces can belong to the same hardware interface.
<li>A routing protocol can be activated for an interface. In this
 case, generation of static routing entries is disabled for this
 interface and access control lists for this interface are automatically
 augmented to permit incoming packets of the routing
 protocol. Currently EIGRP and OSPF are supported.
<li>If <code>routing=manual</code>, no routing code is generated at all. Some
  other means has to be used to configure routing for this interface.
<li> For a description of attribute 'reroute_permit', 
 see <a href="#rerouting">Rerouting inside of security domains</a> below.

 <li> Use attribute 'loopback' to define a loopback interface. A
 loopback interface is not linked to a network, but only used as an
 additional address of a router. Loopback interfaces of different
 routers may share the same name, e.g. interface:r1.loop and
 interface:r2.loop.

<LI>An interface can be marked as disabled.
  See <A HREF="#disabling">Disabling part of the topology</A> below.
<LI>For interface definitions of unmanaged routers all attributes
  can be left out.
<li>An interface definition without any attributes is called a "short
  interface definition".
<li> A short interface can only be used if there is no managed
  interface with static routing enabled in the same network. We need
  this requirement for getting all routing entries generated.

<LI>An interface is handled like a host if it is used as source or
  destination of a rule.

</UL>

<H3><A NAME="any_definition">'Any' object definition</A></H3>
<H4>Syntax</H4>
<PRE>
 any:&lt;name&gt; = { 
     [[ owner = &lt;external_name&gt;, ... ; ]]
     link = {{ 
               network:&lt;name&gt;; 
            |  
	       router:&lt;name&gt;; 
            }} 
 }</PRE>
<UL>
<LI>An 'any' definition is used to represent all networks of a security domain.
<LI>It must not be linked to a managed router.
<LI>At most one 'any' object can be defined for a security domain.
<LI>Generated ACLs use 'any' (i.e. network 0.0.0.0/0.0.0.0) to prevent
enumeration of all networks of a security domain.
<LI>NetSPoC checks that additional any rules are definet to ensure that
intervening networks get access as well.
<LI>See <A HREF="#handling_any">Handling of 'any' objects</A> for details.
</UL>

<h3>Area definition</h3>
<H4>Syntax</H4>
<PRE>
  area:&lt;name&gt; = {
   [[ owner = &lt;external_name&gt;, ... ; ]]
   [[ auto_border; ]]
   {{ 
     border = &lt;object set&gt; ; 
   | anchor = network:&lt;name&gt;;
   }}
  }</pre>

<ul>

<li>Use attribute <code>border</code> to define interfaces which are the
border of the area.

<li>Alternatively use attribute <code>anchor</code> to define a starting point
from where the area extends. Typically <code>anchor</code> is used together
with attribute <code>auto_border</code> which restricts the area to the border
of other areas. 

<li>Use attribute <code>anchor</code> without <code>auto_border</code> to
define an area which stretches across the whole topology.

<li>Exactly one attribute of <code>border</code> and <code>anchor</code> must
be choosen.

<li>Only interfaces of managed routers must be given as <code>border</code>.

</ul>

<H3><A NAME="referencing">Referencing single or sets of network objects</A></H3>
<H4>Syntax</H4>
<PRE>
 &lt;object set&gt; ::= 
    {{ &lt;network object&gt; | &lt;intersection&gt; }} , ...
 &lt;intersection&gt ::= 
    &lt;network object&gt;  &  &lt;complement&gt; [[ & &lt;complement&gt; ...]]
 &lt;complement&gt ::=
    [[!]] &lt;network object&gt;

 &lt;network object&gt; ::=
 {{
   host:&lt;name&gt; 
 | network:&lt;name&gt;
 | any:&lt;name&gt; 
 | interface:&lt;name&gt;.&lt;name&gt;[[.&lt;name&gt;]]
 | network:[local]
 | any:[local]
 | group:&lt;name&gt; 
 | &lt;auto group&gt;
 }}
</PRE>
<UL>

<LI>An &lt;object set&gt; is used to define a set of elements. 

<li>In the simplest case it is the union of comma separated
&lt;network object&gt;s. 

<li>More complicated sets can be build using intersection and
complement. There are two restrictions:

<ol>
<li>At least one subexpression must not be complemented.
<li>All elements of the subexpressions must be of same type.
</ol>

Intersection and complement is typically used to remove some elements
from a given group of elements.

<li>&lt;object set&gt;s are used in groups or as source or destination
of rules.

<li> Hosts, networks and 'any' objects are referenced by the name of
their respective definition.

<LI>When referencing interfaces, we need to use a different syntax
than for interface definitions: the router name followed by a network
name.  

<li>The name for referencing secondary interfaces has three parts: the
router name, the network name and the name of the secondary interface
from its definition.

<li>network:[local] denotes the network, which is directly attached to
an interface. This can only be used as source or destination in a rule
where the counterpart is an interface.

<li>any:[local] is similar to network:[local] but denotes the 'any' object.

<li>A reference to a group is substituted by the elements of the <a
href="#groups_def">group definition</a>.

<li>So called <a href="#auto_group">automatic groups</a> are used to
reference network objects from particular parts of the topology.

</UL>

<h3><a name="auto_group">Automatic groups</a></h3>
<H4>Syntax</H4>
<PRE>

 &lt;auto group&gt; ::=
 {{
   interface:&lt;name&gt;.[&lt;selector&gt;]
 | interface:[ [[ managed & ]] &lt;object set with area&gt;].[&lt;selector&gt;]
 | network:[&lt;object set with area&gt;] 
 | any:[&lt;object set with area&gt;]
 }}

 &lt;selector&gt; ::= {{ auto | all }}
 &lt;object set with area&gt; is like &lt;object set&gt; 
   but with additional area:&lt;name&gt; in &lt;network object&gt;
</PRE>
<UL>

<li>Special names [auto] and [all] can be used as network part in a
reference to an interface.
<ul>

 <li>[auto] denotes the interface on the same side in respect to the
    other object in a rule.  If a router is part of a cyclic subgraph
    then there can be multiple paths to the other object.  In this
    case [auto] denotes multiple interfaces.

 <li>[all] denotes <em>all</em> interfaces of a router.<br>
 But note: Short interfaces (without known IP address) of unmanaged routers
    are excluded.
 
</ul>

<li>[managed & ...] restricts the result to interfaces of <em>managed</em>
routers.

<li><code>interface</code>, <code> network </code> or <code> any
</code> applied to a set of objects is equivalent to applying these to
the single elements and taking the union of results. E.g. <code>
network:[host:a, host:b] </code> is equivalent to <code> network:[host:a],
network:[host:b] </code>.

<li><code>interface:[network:x].[&lt;selector&gt;]</code> takes
some or all interfaces of network:x.

<li><code>interface:[interface:x.y].[&lt;selector&gt;]</code> is
equivalent to <code>interface:x.&lt;selector&gt;</code>.

<li><code>interface:[any:x].[all]</code> takes all border interfaces
of security domain any:x.

<li><code>interface:[area:x].[&lt;selector&gt;]</code> takes
interfaces which are located <em>inside</em> area:x.<br>Note: Border
interfaces are left out.

<li><code>network:[interface:x.y]</code> takes the network attached to
interface:x.y.

<li><code>network:[host:x]</code> takes the network where host:x is located.

<li><code>network:[network:x]</code> is equivalent to
<code>network:x</code>.

<li><code>network:[any:x]</code> takes all networks located inside security
domain any:x.

<li><code>network:[area:x]</code> takes all networks located inside
area:x.

<li><code>any:[interface:x.y], any:[host:x], any:[network:x],
any:[any:x]</code> takes the security domain where the inner object is
located.

<li><code>any:[area:x]</code> takes all secutrity domains located
inside area:x.

<li>Auto interfaces, i.e. with selector [auto] must only be
  used at toplevel and not as inner object of other automatic
  groups. There is one exception from this rule: <code>
  interface:[interface:x.[auto]].[auto] </code> is
  allowed.

</UL>

<H3><A NAME="groups_def">Groups of network objects</A></H3>
<H4>Syntax</H4> <PRE> group:&lt;name&gt; = &lt;object set&gt;;</PRE>
<UL> <LI>A group can be empty <LI>A group can be defined by means of
other groups </UL>

<H3><A NAME="services">Services</A></H3>
<H4>Syntax</H4>
<PRE> service:&lt;name&gt; = 
 {{
   ip 
 | tcp [[[[&lt;range&gt; :]] &lt;range&gt]]
 | udp [[[[&lt;range&gt; :]] &lt;range&gt]]
 | icmp [[&lt;int_1&gt;[[/&lt;int_2&gt;]]]] 
 | proto &lt;int&gt; 
 }} [[&lt;service flag&gt;]] ;</PRE>
<p>with</p>
<PRE> &lt;range&gt; ::= &lt;int_1&gt;[[-&lt;int_2&gt;]]
</PRE>
<P>
<DL>
<DT>tcp, udp
<DD>
<UL>
<li> A &lt;range&gt; denotes a tcp/udp port range
<li> A &lt;range&gt; consisting of only one number denotes a single
port
<li> An empty &lt;range&gt; is equivalent to the full range of all
ports 1 - 65535 
<li> If only one  &lt;range&gt; is given, it describes the destination
port
<li> If two  &lt;range&gt;s are given, they describe source and
destination port
<LI>0 &lt; &lt;int_1&gt; &lt;= &lt;int_2&gt; &lt;= 65535
</UL>
<P>
<DT>icmp
<DD>
<UL>
<LI>&lt;int_1&gt;, &lt;int_2&gt; denote icmp type and code
<LI>0 &lt;= &lt;int_1&gt;,&lt;int_2&gt; &lt;= 255
</UL>
<P>
<DT>protocol
<DD>
<UL>
<LI>&lt;int&gt; is an IP protocol number
<LI>0 &lt; &lt;int&gt; &lt;= 255
</UL>
</DL>
<ul>

<li>For permitting a TCP connection from source to destination, only one rule
    is needed. Answer packets are automatically allowed. For stateful packet
    filters, this is done at the device. For stateless packet filters, netspoc
    automatically generates a rule which allowes any TCP traffic from
    destination to source with flag "established" i.e. no SYN flag set.

<li>Similarly, only one rule is needed to let UDP packets pass from source to
    destination and back. For stateless packet filters, a rule with reversed
    addresses and reversed port numbers is generated.

<li>For service IP and stateless packet filters, a rules with reversed
    addresses is generated. This is needed to get an unified handling for TCP,
    UDP and IP.

</ul>

<h4>Service flags</h4>

One or more &lt;service flag&gt;s can optionally be appended to a service
definition. A &lt;service flag&gt; modifies the rule in which the
corresponding service is used as follows.

<dl>
<dt>stateless<dd>The rule is only applied to stateless devices.

<dt>oneway<dd>At stateless devices, don't automatically generate rules
to permit answer packets.

<dt>reversed<dd>Source and destination are swapped.

<dt>dst_path<dd>The rule is replaced by <em>n</em> rules where the destination
is substituted by interfaces <em>i</em>. <em>i</em> is defined by this rule:
Take from each packet filter on the path from source to destination that
interface <em>i</em> which is headed in source direction.<br> This flag can be
combined with flags dst_net or dst_any to not get the interface but the
corresponding network or 'any' object.

<dt>dst_net<dd>If destination of rule is a host or interface located in
network <em>n</em> then replace destination by <em>n</em>. Otherwise let
destination unchanged. Exception: hosts having a vpn id and interfaces of
manged routers are left unchanged.

<dt>dst_any<dd>First apply rules of flag dst_net above. If destination of rule
is a network located in 'any' object <em>a</em> then replace destination by
<em>a</em>. Otherwise let destination unchanged

<dt>src_path, src_net, src_any<dd>Equivalent to dst_* flags but with source
replaced. 
</dl>

<H3><A NAME="groups_of_services">Groups of services</A></H3>
<H4>Syntax</H4>
<PRE>  servicegroup:&lt;name&gt; = &lt;service&gt;, ... ;</PRE>
<P>with</P>
<PRE>
  &lt;service&gt; ::= {{ service:&lt;name&gt; | servicegroup:&lt;name&gt; }}</PRE>
<UL>
<LI>A servicegroup can be empty.
<LI>A servicegroup can be defined by means of other servicegroups.
</UL>

<H3><A NAME="policies_def">Policies</A></H3>
<H4>Syntax</H4>
<PRE>
  policy:&lt;name&gt; = {
     [[ description = &lt;text_to_end_of_line&gt ]]
     user = &lt;object set&gt;;
     &lt;policy_rule&gt; * 
  }</PRE>
<P>with</P>
<PRE>
  &lt;policy_rule&gt; ::=
  {{ permit | deny }}
        src = &lt;policy_object&gt;;
        dst = &lt;policy_object&gt;;
        srv = &lt;service&gt;, ... ;
  &lt;policy_object&gt; ::= {{ user | &lt;object set&gt; }};</PRE>
<UL>
<LI>Order of rules doesn't matter.
<LI>Deny rules override all permit rules.
<LI>Policies give a descriptive name to a group of related rules. 
<li>Policies are useful for documentation and reporting purposes. 
<li>The rules of a policy must be related in that they all use the same source
or destination object(s). This is enforced by the keyword "user" which
must be used either as src or dst or both parts of a rule.
</UL>

<h3><a name="restrict_def">Path restrictions</a></h3>
<H4>Syntax</H4>
<PRE> 
 pathrestriction:&lt;name&gt; = 
   [[ description = &lt;text_to_end_of_line&gt ]]
   &lt;object set&gt; ;</PRE>
<ul>
 <li>Path restrictions are used to restrict paths inside cyclic
  subgraphs of the topology.
 <li>All paths running through two or more interfaces belonging to the
  same path restriction are discarded i. e. marked as invalid.
 <li>Only interfaces of managed routers can be used to define a 
     pathrestriction .
 <li>Path restrictions must not be used to discard <em>all</em> paths
  between some source / destination pair. Use a policy with deny rules
  instead.
 <li>A pathrestriction is automatically added for each group of interfaces
 belonging to a VRRP or HSRP cluster.
</ul>

<h3><a name="global_NAT">Global NAT definition</a></h3>
<H4>Syntax</H4>
<PRE>
 nat:&lt;name&gt; = { 
   ip = &lt;ip-adr&gt;&lt;mask&gt;; 
   dynamic;
   [[ subnet_of = network:&lt;name&gt;; ]] 
 }</PRE>
with <code>&lt;mask&gt;</code> defined as 
<a href="#network_definition">above</a>.

<p>A global NAT definition can be used as a shortcut for applying multiple
identical dynamic NAT definitions to all networks in some area. See <a
href="#NAT">network address translation</a> for details.

<h2><a name="NAT">Network address translation (NAT)</a></h2>

Network address translation occurs at routers.
At one side of a router, a network object is visible with its original
IP address; at another side of the router this address is translated
to another address.

<p>Currently, NetSPoC supports static and dynamic NAT for whole
networks.

<p>For static NAT, the translated address uses the same netmask as the
original network. The translation is automatically applied to all host and
interface definitions of the translated network. A separate NAT
definition for hosts or interfaces is not possible in this case.

<p>For dynamic NAT, the translated address can use a different netmask than
the original network. Typically a smaller network is used for translation. IP
addresses are translated dynamically, hence hosts and interfaces of this
network are not visible from outside. But a dynamic translation of a network
can be augmented with static translations for single hosts or interfaces of
this network.

<p>Syntax for NAT is divided into two parts:
<ol>
<li>A <em>NAT definition</em> denominates the alternate IP address of an
network object.
<li>A <em>NAT binding</em> applies a set of NAT definitions to an
interface. 
</ol>

<h3>Example</h3>

Network "extern" has bad IP addresses, which are not usable at network
"intern". At router "r_ext" static NAT occurs. The NAT definition and
NAT binding tells NetSPoC, that and where NAT occurs.<br>
Hosts "extern_www" and "extern_mail" are visible with addresses
10.7.128.10 and 10.7.128.25 from "intern".

<pre>network:extern = {
 ip = 128.1.2.0; mask = 255.255.255.0;
 # static NAT definition
 nat:bad128 = { ip = 10.7.128.0; }
 host:extern_www = { ip = 128.1.2.10; }
 host:extern_mail = { ip = 128.1.2.25; }
}

router:r_ext = {
 interface:extern;
 interface:intern = {
  ip = 10.1.1.1;
  # NAT binding
  nat = bad128;
 }
}

network:intern = { ip = 10.1.1.0; mask = 255.255.255.0; }
</pre>

All NAT definitions with the same name establish a set of NAT
definitions.  A set of NAT definition is effective <em>behind</em>
that interface where the NAT binding with the same name occurs. We are
defining <em>behind an interface</em> as that part of the topology
which is seen when looking from the router to that interface.

<p>Multiple NAT definitions can be given for a single network. These are bound
to different interfaces to make different NAT definitions effective at
different parts of the topology.

<p>For dynamic NAT, multiple networks can use identical NAT definitions. This
is used to masquerade multiple networks to a single address space.

<p>A global NAT definition can be used as a shortcut for applying multiple
identical dynamic NAT definitions to all networks located <em>before</em> that
interface where the NAT binding with this name occurs.

<p>NetSPoC needs to know about NAT for different reasons:
<ol>
<li>When generating ACLs for an interface it must use those IP
    addresses which are visible in the area of this interface.
<li>The same is true when generating static routing entries.
<li>For some types of devices NetSPoC is able to actually generate the
   NAT translation rules. This is currently true for PIX firewalls.
</ol>

<h2><a name="secondary">Secondary packet filters</a></h2>
In a given topology we can get chains of managed packet filters
on the path from src to dst. Each packet filter is a "full" packet
filter by default, which does full filtering for each rule 
again and again.<br>
A secondary packet filter gets a simpler rule set.<br>
A given rule describes traffic starting at src and terminating at dst.
If there is at least one full packet filter on the path from src to dst, all
secondary packet filters on this path get a simplified ACL line for the current
rule. This ACL line allows any IP packets from the src network to the dst
network. This simplified filtering assures that the traffic comes from the
right src and goes to the right dst.<br>
If, for a given rule, there is a chain of secondary packet filters without a
full packet filter, all devices do full filtering.<br>
A secondary packet filter is declared with attribute
"managed = secondary". This can be useful if a router has not
enough memory for storing a complete set of filter rules and most of
the packets get fully filtered already by some other managed device.
<h2><a name="routing">Routing</a></h2>

<h4>Static and dynamic routing</h4>
<p>From its knowledge about the topology, NetSPoC generates static
routing entries for each managed device. If an interface of a device
has an attribute "routing=&lt;routing protocol&gt;", no static routing
entries are generated for networks behind that interface.

<p>Routing entries are only generated for network objects, which are
used in some rule. I.e. no routing entries are generated for unused
parts of the topology. Even for network objects which are only used as
source of a rule, routing entries are generated, since stateful packet
filters implicitly allow answer packets back to the source. If an
'any' object is used in a rule, routing entries for all networks part
of this 'any' object are generated.

<h4>Default route</h4>
<p>A default route can be defined for a topology by placing a network
with IP address and mask equal 0.0.0.0. Such a network must have an
attribute "route_hint".

<p>Alternatively, NetSPoC can automatically define a default route for
each managed device as a means to reduce the number of static routing
entries. 
<ul>
<li>At each managed device, a default route is automatically inserted such
that it replaces the maximum number of routing entries. 
<li>This behavior can be switched on or off by option --auto_default_route.
<li>This option must be switched off, if a user defined default route is
given.
<li>This behavior is automatically disabled for routers where at least one
interface has dynamic routing enabled. 
</ul>

<h4>Optimization</h4>
Multiple routing entries for networks which are in a subnet
relation, are replaced by a single routing entry.

<h2><a name="rerouting">Rerouting inside of security domains</a></h2>

Internal traffic which flows inside a security domain isn't
filtered at all. Sometimes an interface X of a managed (filtering)
router is used as a default route for traffic which normally flows
inside a security domain. This would cause internal traffic to be
routed to X, which would deny this traffic.

<p>NetSPoC is prepared to handle this case by defining an attribute
'reroute_permit' for a managed interface. Value of this attribute is a
list of networks, for which any internal traffic should be allowed.

<h4>Example</h4>
router:x is managed, router:y is unmanaged.
<pre>
router:x -- network:a -- router:y -- network:b
</pre>


<p>network:a and network:b are inside one security domain, since
router:y isn't managed. If traffic from network:a to network:b is
routed via router:x and router:y, router:x would deny this traffic.
Use "reroute_permit = network:b" at "interface:x.a" to permit any
incoming traffic to network:b.
 
<h2><a name="virtual">Virtual interface</a></h2>
A virtual interface defines a shared IP address and type of redundancy
protocol at two or more interfaces. Currently, redundancy protocols VRRP and
HSRP are supported. 
<ul>
<li> The virtual IP address is used as destination when generating static
routes.
<li> Access control lists for the associated real interfaces are automatically
 augmented to permit incoming packets of the redundancy protocol.
<Li> At least two interfaces with the same virtual IP are needed.
<li> The set of interfaces with same virtual IP
<ul>
<li> must be linked to the same network and
<li> must be part of the same cyclic subgraph.
</ul>
<li> A virtual IP must be different from normal IP address(es).
<li> The 'id' attribute is optional. It is used for consistency checks but
currently not used when generating code for managed devices.
</ul>

<H2><A NAME="disabling">Disabling part of the topology</A></H2>
<P>An interface can be explicitly marked as disabled.  This implicitly
marks all network objects as disabled, that are located <em>behind</em>
this interface. We are defining <em>behind an interface</em> as that
part of the topology which is seen when looking from the router to
that interface. All occurrences of disabled network objects in groups and
rules are silently discarded.</P>

<h2><a name="encryption">Encryption</a></h2>
<h3><a name="crypto_syntax">Syntax</a></h3>
<pre>
  crypto:&lt;name&gt; = {
     [[ description = &lt;text_to_end_of_line&gt ]]
     type = ipsec:&lt;name&gt;;
     [[ hub = &lt;object set&gt;;
       spoke = &lt;object set&gt;;
     ]]
     mesh = &lt;object set&gt;; *
     &lt;crypto_rule&gt; * 
  }</PRE>
<P>with</P>
<PRE>
  &lt;crypto_rule&gt; ::=
  {{ permit | deny }}
        src = &lt;object set&gt;;
        dst = &lt;object set&gt;;
        srv = &lt;service&gt;, ... ;
</PRE>

<pre>
  ipsec:&lt;name&gt; = {
     key_exchange = isakmp:&lt;name&gt;;
     esp_encryption = {{ aes | aes192 | des | 3des | none }};
     esp_authentication = {{ md5_hmac | sha_hmac | none }};
     ah = {{ md5_hmac | sha_hmac | none }};
     pfs_group = {{ 1 | 2 | 5 }};
     lifetime = &lt;number&gt; &lt;timeunit&gt;;
  }</pre>

<pre>
  isakmp:&lt;name&gt; = {
     identity = {{ address | fqdn }};
     nat_traversal = {{ on | off }};
     authentication = {{ preshare | rsasig }};
     encryption = {{ aes | aes192 | des | 3des }};
     hash = {{ md5 | sha }};
     group = {{ 1 | 2 | 5 }};
     lifetime = &lt;number&gt; &lt;timeunit&gt;;
  }</pre>
<P>with</P>
<PRE>
  &lt;timeunit&gt; ::= 
    {{ sec | min | hour | day | secs | mins | hours | days }};
</PRE>

<h2>Remote access</h2>

Support for remote access by tele worker or remote office has been
implemented.

<dl>
<dt>Tele worker
<dd>
<ul>
<li>VPN software client
<li>authenticate itself by certificate
<li>dynamically get IP address from radius server via VPN device
</ul>

<dt>Remote office
<dd>
<ul>
<li>VPN router with attached network
<li>router authenticates traffic by certificate
<li>router has public IP address at outside interface
<li>router has fixed private IP address at inside interface
<li>fixed IP address range for attached network
</ul>

<dt>Both
<dd>
<ul>
<li>build VPN tunnel to central VPN device
<li>VPN device uses certificate name to authenticate at radius server
<li>radius server sends indivdual access list to VPN device
<li>VPN device permits authorized access for client
</ul>
</dl>

This concept has been implemented for Cisco VPN 3000 devices which
send authorization request to one or more radius servers. VPN is build
using IPSec tunnels.

<h3>Cisco VPN 3000</h3>
<dl>
<dt>new type of router 
<dd> type=vpn3k
<dt>additional attribute for router
<dd> radius_servers=&lt;object set&gt;
<dt>additional attributes for interface
<dd><ul> 
<li>auto_crypto=ipsec:&lt;name&gt;
<li> no_check
</ul>
<dt>additional syntax for hosts
<dd> host:id:certificate-name
<dt>additional attribute for network
<dd> id=&lt;user[[@domain]]&gt;
<dt>additional optional attribute at host with id, network with id, network having id hosts and router of type vpn3k
<dd> radius_attributes={&lt;key&gt;=&lt;value&gt;;*}
</dl>
<p>
<h4>Additional restrictions</h4>
<ul>
<li>Router needs to have exactly on interface with attribute 'no_check'.
<li>Source of rule must have ID when entering interface without attribute 'no_check',

<li>Attribute 'radius_servers' needs to be defined for router of type
vpn3k. Each element must be a host.

<li>A network having id hosts must not be used in a rule.
</ul>

<p>
Multiple instances if one host:id:&lt;name&gt; can get defined in
different networks of a topology. When referencing an id host, one has
to append the name of the enclosing newtork to make the reference
definite.  <code> host:id:&lt;name&gt; </code> is referenced as <code>
host:id:&lt;name&gt;.&lt;network&gt; </code>

<h4>Special handling of access lists at vpn3k device</h4>
<ul>
<li>First use all regular rules were destination is in one of the denied
  networks below. 
<li>Deny access to all networks, which talk to the vpn3k device, but
  which are not protected by some managed device; i.e.
  <ul>
  <li> container network of id hosts,
  <li>network of remote office with unmanged VPN router
  <li>networks attached to the 'no_check' interface of the vpn3k device.
  </ul>
<li>Permit any traffic from IP address of remote host or network.
</ul>

<H2><A NAME="handling_any">Handling of 'any' objects</A></H2>
<P>The meaning of 'any' is different in a NetSPoC rule from that in an ACL.
For NetSPoC, any:X means "any network object of the security domain
where any:X is located".
For an ACL which filters incoming traffic of an interface, any
(i.e. 0.0.0.0/0.0.0.0) means "any network object beyond the interface
where the ACL is applied to".</P>
<DL>
<DT>
as source:<DD>any data object connected directly or indirectly with
this interface.
<DT>
as destination:<DD>any data object located behind the router where the
interface belongs to.
</DL>

<H2><A NAME="pix_levels">PIX security levels</A></H2>
<P>PIX firewalls have a security level associated with each interface.
We don't want to expand our syntax to state them explicitly,
but instead we try to derive the level from the interface name:
<ul>
<li>Interface 'inside' gets level 100
<li>Interface 'outside' gets level 0
<li>For each other interface there must be a number at the end of its
name which is taken as the relative security level.<br> I.e 'DMZ-slot:4'
&lt; 'DMZ-slot:5'
</ul>
It is not necessary the find the exact level; what we need to know
is the relation of the security levels to each other.</P>

<H2><A NAME="redundant_rules">Automatic deletion of redundant rules</A></H2>
<P><em>Fully implemented, but documentation has to be done ...</em></P>

<H2><A NAME="generated_code">Generated Code</A></H2>
<UL>
<LI>Access control lists
<LI>Routing
<LI>NAT commands for some devices
</UL>
<H2><A NAME="supported_devices">Supported devices</A></H2>
<UL>
<LI>PIX 
<ul>
<li>access-list (conduit and outbound are not supported)
<li>object-group
<li>icmp, telnet, ssh, http
<li>route
</ul>
<LI>Cisco IOS with firewall feature set
 <ul>
 <li>ip access-list extended
 <li>ip route
 </ul>
<li>Cisco IOS without firewall feature set
 <ul>
 <li>ip access-list extended (rules for answer packets are added automatically)
 <li>ip route
 </ul>
<li>Linux 
 <ul>
  <li>iptables 
  <li>ip route
 </ul>
</UL>

<P> Copyright (c) 2007, Heinz Knutzen 
<A HREF="mailto:heinzknutzen@users.berlios.de">heinzknutzen@users.berlios.de</A></P>

</BODY>
</HTML>

<!--  LocalWords:  Rerouting NetSPoC nat EIGRP OSPF src dst tcp udp icmp servicegroup
 -->
<!--  LocalWords:  servicegroups srv pathrestriction netmask www stateful DMZ
 -->
<!--  LocalWords:  iptables Knutzen denominates ACLs IOS VRRP HSRP
 -->
