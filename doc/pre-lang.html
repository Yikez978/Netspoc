<HTML>
<HEAD>
<TITLE>Description Language for Security Policy and Topology</TITLE>
</HEAD>

<BODY bgcolor=#FFFFFF>

<UL>
 <LI><A HREF="#language">Description Language for Security Policy and Topology</A></LI>
 <UL>
  <LI><A HREF="#overview">Overview</A></LI>
  <UL>
   <LI><A HREF="#rules">Rules</A></LI>
   <LI><A HREF="#policies">Policies</A></LI>
   <LI><A HREF="#network_objects">Network Objects</A></LI>
   <LI><A HREF="#service_definitions">Service Definitions</A></LI>
   <LI><A HREF="#groups">Groups</A></LI>
   <LI><A HREF="#service_groups">Service Groups</A></LI>
  </UL>
  <LI><A HREF="#detailed">Detailed description of network objects</A></LI>
  <UL>
   <LI><A HREF="#general_syntax">General syntax</A></LI>
   <LI><A HREF="#network_definition">Network Definition</A></LI>
   <LI><A HREF="#host_definition">Host definition</A></LI>
   <LI><A HREF="#router_definition">Router definition</A></LI>
   <LI><A HREF="#interface_definition">Interface definition</A></LI>
   <LI><A HREF="#every_definition">'Every' object definition</A></LI>
   <LI><A HREF="#any_definition">'Any' object definition</A></LI>
   <LI><A HREF="#referencing">Referencing network objects</A></LI>
   <LI><A HREF="#groups_def">Groups of network objects</A></LI>
   <LI><A HREF="#services">Services</A></LI>
   <LI><A HREF="#groups_of_services">Groups of services</A></LI>
   <LI><A HREF="#rules_def">Rules</A></LI>
   <LI><A HREF="#policies_def">Policies</A></LI>
  </UL>
  
  <li><A HREF="#secondary">Secondary packet filters</A></li>
  <li><a href="#routing">Routing</a>
  <li><a href="#rerouting">Rerouting inside of security domains</a>
  <LI><A HREF="#disabling">Disabling part of the topology</A></LI>
  <LI><A HREF="#handling_any">Handling of 'any' objects</A></LI>
  <LI><A HREF="#pix_levels">PIX security levels</A></LI>
  <LI><A HREF="#redundant_rules">Automatic deletion of redundant rules</A></LI>
  <LI><A HREF="#generated_code">Generated Code</A></LI>
  <LI><A HREF="#supported_devices">Supported devices</A></LI>
 </UL>
</UL>

<HR>
<P>
<H1><A NAME="language">Description Language for Security Policy and Topology</A></H1>

<H2><A NAME="overview">Overview</A></H2>

<H3><A NAME="rules">Rules</A></H3>
<P>Network objects and service definitions are used in rules to describe network
traffic which can or must not pass packet from source to destination.</P>

<h3><a name="policies"></a>Policies</h3>
<ul>
<li>Policies are used to group together related rules.
<li>All rules of a single policy must refer to the same network objects in their source or destination.
<li>Policies have a name which may be used for documentation or
reporting purposes.
</ul>

<H3><A NAME="network_objects">Network Objects</A></H3>
<UL>
<LI>have name and IP address
<LI>describe topology
<LI>can be used as source and destination of rules
</UL>

<H3><A NAME="service_definitions">Service Definitions</A></H3>
<UL>
<LI>have a name
<LI>describe properties of network traffic as they typically can be
filtered by packet filters (i.e. type of protocol, port number)
</UL>

<H3><A NAME="groups">Groups</A></H3>
<UL>
<LI>have a name
<LI>are used to group network objects
<LI>are used in rules for simplified management of large numbers of
network objects.
</UL>

<H3><A NAME="service_groups">Service Groups</A></H3>
<UL>
<LI>
have a name
<LI>are used to group service definitions
<LI>are used in rules
</UL>

<H2><A NAME="detailed">Detailed description of network objects</A></H2>
<P>The topology is built from networks and routers.
A router and a network are connected by an interface.
Networks may have any number of hosts, which are located inside the
network.</P>
<P>Routers may be managed or unmanaged. For a managed router, NetSPoC
generates access control lists which control what traffic can pass
this router and what traffic is blocked.
The whole topology is partitioned into different security domains by
managed routers.</P>
<P>Special network objects called 'any' objects and 'every' objects may
be defined which denote all network objects in a security domain.</P>

<H3><A NAME="general_syntax">General syntax</A></H3>
<P>All network objects and groups have a typed name like &lt;type&gt;:&lt;name&gt;.</P>
<P>&lt;name&gt; is build from one ore more alphanumerical and underscore
characters. The current locale settings are used, i.e. accented
characters are allowed for european locale settings.</P>
<P>&lt;ip-adr&gt; denotes an IP address. Currently NetSPoC handles IP v4
addresses n.n.n.n with 0 &lt;= n &lt;= 255</P>
<P>&lt;interface_name&gt; may contain any characters, even interspersed
whitespace. Currently characters from <CODE>[;,=]</CODE> are not allowed, since
we use them as delimiters.</P>
<P>&lt;int&gt; is an integer</P>
<P>Meta symbols in syntax definitions below:</P>
<UL>
<LI>&lt;..&gt; denote something defined elsewhere
<LI>[..] denotes an optional part
<LI>{{..|..}} denotes alternatives.
<P>Note: single { and } characters stand for themselves.</P>
<LI>... * means any number of the left part
</UL>

<H3><A NAME="network_definition">Network Definition</A></H3>
<H4>Syntax</H4>
<PRE>
  network:&lt;name&gt; = {
     {{
         [ route_hint; ]
	 [ subnet_of = network:&lt;name&gt;; ]
         ip = &lt;ip-adr&gt;; mask = &lt;ip-adr&gt;;
	 &lt;network NAT definition&gt; *
         &lt;host definition&gt; *
     |
         unnumbered
     }}
  }

  &lt;network NAT definition&gt; ::=
         nat:&lt;name&gt; = { ip = &lt;ip-adr&gt;; [ mask = &lt;ip-adr&gt;; ] [dynamic;] }
</PRE>

<UL>
<LI>A network is described by an ip address and a mask or
<LI>may alternatively be marked as unnumbered.
<LI>It may contain any number of host definitions.
<LI>Unnumbered networks must have no host definitions at all.
<LI>If used as source or destination of a rule, the ip/mask is used
directly for generating ACLs.
<LI>An unnumbered network must not be used in rules.
<LI>All networks must be disjunct if option 'strict_subnets' is
active. Exceptions must be declared explictly:
<UL>
<LI>route_hint: This network may enclose other networks, but it must
not have host definitions.
<LI>subnet_of: The enclosing network must be stated explicitly.
</UL>
This may be useful for a large topology, where a network may easily be
redefined by mistake.
</UL>

<H3><A NAME="host_definition">Host definition</A></H3>
<H4>Syntax</H4>
<PRE>
  &lt;host definition&gt; ::=
        host:&lt;name&gt; = {   
	 {{
	   ip = &lt;ip-adr&gt;, ...;
         |
           range = &lt;ip-adr&gt; - &lt;ip-adr&gt;;
	 }}
           &lt;NAT definition&gt; *
        }

  &lt;NAT definition&gt; ::=
        nat:&lt;name&gt; = { ip = &lt;ip-adr&gt;; }
</PRE>

<UL>
<LI>A host may only be defined inside a network definition.
<LI>It has one or more IP addresses or
<LI>alternatively an ip address range with first address &lt; second address
<LI>IP addresses must match ip/mask of the surrounding network.
<LI>If used as source or destination of a rule, one ACL entry is
generated for each IP address.
<LI>NetSPoC tries to automatically convert successive IP addresses from one
or multiple hosts of a common network to an IP range.
<LI>During code generation, an IP range is split into a number of
subnetworks which cover the range. One ACL entry is generated for
each subnetwork.
</UL>

<H3><A NAME="router_definition">Router definition</A></H3>
<H4>Syntax</H4>
<PRE>
  &lt;router definition&gt; ::=
  router:&lt;name&gt; = {
     {{
        managed [ = {{ full | secondary }} ] ;
        model = &lt;name&gt;;
        static_manual;
	&lt;interface definition&gt; *
     |
        [ model = &lt;name&gt;; ]
        {{ &lt;interface definition&gt; | &lt;short interface definition&gt; }} *
     }}
  }</PRE>
<UL>
<li>A router may be managed or unmanaged.
<li>Managed routers may be of type 'full' or of type 'secondary'. A
type 'full' is assumed, if no value is given. See <A
HREF="#secondary">secondary packet filters</A> below for a detailed
description. 
<LI>Managed routers need to be precisely described since this
 information is needed for code generation later.
<LI>The router model is used to generate correct code for different
 router models.<BR>Currently three models are supported:
<UL>
<LI>PIX for Cisco PIX firewalls
<LI>IOS_FW for Cisco IOS routers with state full inspection
<li>IOS for stateless Cisco IOS
</UL>
<font size="-1">Note: IOS_FW was named IOS before NetSPoC version 1.3
</font> 
<LI>A PIX firewall may be marked as 'static_manual' if no 'static'
commands should be generated. We use this if we know, that incoming traffic is
only allowed, after some outgoing connection has been established.
<LI>A Router may have any number of interface definitions.
<LI>For unmanaged routers, almost all attributes are optional.
<LI>If used as source or destination of a rule, a router is handled like
a group of its interfaces.
</UL>

<H3><A NAME="interface_definition">Interface definition</A></H3>
<H4>Syntax</H4>
<PRE>
  &lt;interface definition&gt; ::= 
    interface:&lt;name&gt; = {
         {{ ip = &lt;ip-adr&gt;, ...; | unnumbered; }}
         &lt;NAT definition&gt; *
         [ &lt;NAT binding&gt; }
         [ hardware = &lt;interface_name&gt;; ]
	 [ routing = OSPF; ]
	 [ reroute_permit = network:&lt;name&gt;, ...; ]
         [ disabled ; ]
    }

  &lt;short interface definition&gt; ::=
    interface:&lt;name&gt;;

 
  &lt;NAT definition&gt; ::=
         nat:&lt;name&gt; = { ip = &lt;ip-adr&gt;; }
  &lt;NAT binding&gt; ::=
         nat = &lt;name&gt;;
</PRE>

<UL>
<LI>Interfaces have no name of their own; instead a network name is used
  to indicate that the interface is linked to a network of the same
  name.
<LI>An interface may have one or more IP addresses. All of them must
  match the IP/mask of the corresponding network.
<LI>An unnumbered interface must only be linked to an unnumbered network.
<LI>The 'hardware' attribute indicates, which hardware interface the router
  belongs to. THis attribute is mandatory for managed routers.
<LI>Multiple interfaces may belong to the same hardware interface.
<li>A routing protocol may be activated for an interface. In this
 case, generation of static routing entries is disabled for this
 interface and the access lists for this interface are automatically
 augmented to permit incoming packets of the routing
 protocol. Currently only OSPF is supported.
 <li> For a description of attribute 'reroute_permit', 
 see <a href="#rerouting">Rerouting inside of security domains</a> below.
<LI>An interface may be marked as disabled.
  See <A HREF="#disabling">Disabling part of the topology</A> below.
<LI>For interface definitions of unmanaged routers almost all attributes
  may be left out.
<LI>If a network is linked to a short interface definition, it must not
  be linked to any other interface. We need this requirement for
  getting all routing entries generated.
<LI>If used as source or destination of a rule an interface is handled
  like a host.
</UL>

<H3><A NAME="every_definition">'Every' object definition</A></H3>
<H4>Syntax</H4>
<PRE>
 every:&lt;name&gt; = { link = {{ network:&lt;name&gt;; | router:&lt;name&gt;; }} }</PRE>
<UL>
<LI>An 'every' definition is equivalent to a group of all networks of
a security domain.
<LI>It must not be linked to a managed router.
</UL>

<H3><A NAME="any_definition">'Any' object definition</A></H3>
<H4>Syntax</H4>
<PRE>
 any:&lt;name&gt; = { link = {{ network:&lt;name&gt;; |  router:&lt;name&gt;; }} }</PRE>
<UL>
<LI>An 'any' definition is used to represent all networks of a security domain.
<LI>It must not be linked to a managed router.
<LI>At most one 'any' object can be defined for a security domain.
<LI>Generated ACLs use 'any' (i.e. network 0.0.0.0/0.0.0.0) to prevent
enumeration of all networks of a security domain.
<LI>NetSPoC generates additional deny rules to prevent
intervening networks getting undesired access.
<LI>See <A HREF="#handling_any">Handling of 'any' objects</A> for details.
</UL>

<H3><A NAME="referencing">Referencing network objects</A></H3>
<H4>Syntax</H4>
<PRE>
 &lt;network object&gt; ::=
 {{
   host:&lt;name&gt; 
 | network:&lt;name&gt; 
 | router:&lt;name&gt; 
 | interface:&lt;name&gt;.&lt;name&gt; 
 | any:&lt;name&gt; 
 | every:&lt;name&gt;
 | group:&lt;name&gt; 
 }}</PRE>
<UL>
<LI>Network objects are referenced in groups or as source or destination
of rules.
<LI>When referencing interfaces, we need to use a different syntax than
for interface definitions: the router name followed by a network name.
</UL>

<H3><A NAME="groups_def">Groups of network objects</A></H3>
<H4>Syntax</H4>
<PRE>
 group:&lt;name&gt; = &lt;network object list&gt;;</PRE>
<p>with</p>
<PRE>
 &lt;network object list&gt; :== &lt;network object&gt;, ...</PRE>
<UL>
<LI>A group may be empty
<LI>A group may be defined by means of other groups
</UL>

<H3><A NAME="services">Services</A></H3>
<H4>Syntax</H4>
<PRE>
 service:&lt;name&gt; = 
 {{
   ip 
 | tcp [&lt;range&gt; -&gt;] &lt;range&gt
 | udp [&lt;range&gt; -&gt;] &lt;range&gt
 | icmp [&lt;int_1&gt;[/&lt;int_2&gt;]] 
 | proto &lt;int&gt; 
 }} ;</PRE>
<p>with</p>
<PRE>
&lt;range&gt; ::= [&lt;int_1&gt;[-&lt;int_2&gt;]]
</PRE>
<P>
<DL>
<DT>tcp, udp
<DD>
<UL>
<li> A &lt;range&gt; denotes a tcp/udp port range
<li> A &lt;range&gt; consisting of only one number denotes a single
port
<li> An empty &lt;range&gt; is equivalent with the full range of all
ports 1 - 65535 
<li> If only one  &lt;range&gt; is given, it describes the destination
port
<li> If two  &lt;range&gt;s are given, they describe source and
destination port
<LI>0 &lt; &lt;int_1&gt; &lt;= &lt;int_2&gt; &lt;= 65535
</UL>
<P>
<DT>icmp
<DD>
<UL>
<LI>&lt;int_1&gt;, &lt;int_2&gt; denote icmp type and code
<LI>0 &lt;= &lt;int_1&gt;,&lt;int_2&gt; &lt;= 255
</UL>
<P>
<DT>protocol
<DD>
<UL>
<LI>&lt;int&gt; is a IP protocol number
<LI>0 &lt; &lt;int&gt; &lt;= 255
</UL>
</DL>
<ul>
<li>For describing a tcp connection between client and server, only
one rule is needed with client as source. The packets back from the
destination are allowed implicitly. 
<li>Similar to tcp connections, only one rule is needed to let udp
packets pass from source to destination and back.
<li>When using service "ip" in a rule, currently only packets from
source to destination are allowed. But state full packet filters let
pass answer packets for tcp connections anyway. To get a unified
handling for tcp, udp and ip for state full and stateless packet filters,
we might change this in the future, to let ip packets pass in both
directions, with only one rule.
</ul>

<H3><A NAME="groups_of_services">Groups of services</A></H3>
<H4>Syntax</H4>
<PRE>  servicegroup:&lt;name&gt; = &lt;service list&gt;;</PRE>
<P>with</P>
<PRE>
  &lt;service list&gt; ::= &lt;service&gt;, ...
  &lt;service&gt; ::= {{ service:&lt;name&gt; | servicegroup:&lt;name&gt; }}</PRE>
<UL>
<LI>A servicegroup may be empty.
<LI>A servicegroup may be defined by means of other servicegroups.
</UL>

<H3><A NAME="rules_def">Rules</A></H3>
<H4>Syntax</H4>
<PRE>
  &lt;rule&gt; ::=
  {{ permit | deny }}
        src = &lt;network object list&gt;;
        dst = &lt;network objec listt&gt;;
        srv = &lt;service list&gt;;</PRE>
<UL>
<LI>Order of rules doesn't matter.
<LI>Deny rules override all permit rules.
</UL>

<H3><A NAME="policies_def">Policies</A></H3>
<H4>Syntax</H4>
<PRE>
  &lt;policy&gt; ::= {
        user = &lt;network object list&gt;;
	&lt;policy_rule&gt; * 
  }</PRE>
<P>with</P>
<PRE>
  &lt;policy_rule&gt; ::=
  {{ permit | deny }}
        src = &lt;policy_object&gt;;
        dst = &lt;policy_object&gt;;
        srv = &lt;service list&gt;;
  &lt;policy_object&gt; ::= {{ user | &lt;network object list&gt; }}</PRE>
<UL>
<LI>Policies give a descriptive name to a group of related rules. 
<li>Policies are useful for documentation and reporting purposes. 
<li>The rules of a policy must be related in that they all use the same source
or destination object(s). This is enforced by the keyword "user" which
must be used either as src or dst or both parts of a rule.
</UL>


<h2><a name="secondary">Secondary packet filters</a></h2>
In a given topology we may have chains of managed packet filters
on the path from src to dst. Each packet filter is a "full" packet
filter by default, which does full filtering for each rule 
again and again.<br>
A secondary packet filter has simpler rules for	permitted traffic
which gets further filtering by a full packet filter. In this
case it allows any IP packets from the src network to the dst network.
This simple filterung assures that the traffic comes from the rigth
src and goes to the rigth dst.<br>
A secondary packet filter is declared by the attribute
"managed = secondary". This may be usefull if a router has not
enough memory for storing a complete set of filter rules and most of
the packets get fully filtered already by some other managed device.

<h2><a name="routing">Routing</a></h2>

<h4>Static and dynamic routing</h4>
<p>From its knowledge about the topology, NetSPoC generates static
routing entries for each managed device. If an interface of a device
has an attribute "routing=&lt;routing protocol&gt;", no static routing
entries are generated for networks behind that interface.

<p>Routing entries are only generated for network objects, which are
used in some rule. I.e. no routing entries are generated for unsused
parts of the topology. Even for network objects which are only used as
source of a rule, routing entries are generated, since stateful packet
filters implicitly allow answer packets back to the source. If an
'any' object is used in a rule, routing entries for all networks part
of this 'any' object are generated.

<h4>Default route</h4>
<p>A default route may be defined for a topology by placing a network
with IP address and mask equal 0.0.0.0. Such a network must have an
attribute "route_hint".

<p>Alternativly, NetSPoC can automatically define a default route for
each managed device as a means to reduce the number of static routing
entries. At each managed device, a default route is automtically
inserted such that it replaces the maximum number of routing
entries. This behaviour may be switched on or off by option
$auto_default_route. This option must be off, if a user defined
default route is given.


<h4>Optimization</h4>
Multiple routing entries for networks which are in a subnet
relation, are replaced by a single routing entry.

<h2><a name="rerouting">Rerouting inside of security domains</a></h2>

Internal traffic which flows inside a security domain isn't
filtered at all. Sometimes an interface X of a managed (filtering)
router is used as a default route for traffic which normally flows
inside a security domain. This would cause internal traffic to be
routed to X, which would deny this traffic.

<p>NetSPoC is prepared to handle this case by defining an attribute
'reroute_permit' for a managed interface. Value of this attribute is a
list of networks, for which any internal traffic should be allowed.

<h4>Example</h4>
router:x is managed, router:y is unmanaged.
<pre>
router:x -- network:a -- router:y -- network:b
</pre>


<p>network:a and network:b are inside one security domain, since
router:y isn't managed. If traffic from network:a to network:b is
routed via router:x and router:y, router:x would deny this traffic.
Use "reroute_permit = network:b" at "interface:x.a" to permit any
incoming traffic to network:b.

<H2><A NAME="disabling">Disabling part of the topology</A></H2>
<P>An interface may be explicitly marked as disabled.  
This implicitly marks all network objects as disabled, that are
directly or indirectly connected to this interface.
All occurrences of disabled network objects in groups and rules are
silently discarded.</P>

<H2><A NAME="handling_any">Handling of 'any' objects</A></H2>
<P>The meaning of 'any' is different in a NetSPoC rule from that in an ACL.
For NetSPoC, any:X means "any network object of the security domain
where any:X is located".
For an ACL which filters incoming traffic of an interface, any
(i.e. 0.0.0.0/0.0.0.0) means "any network object beyond the interface
where the ACL is applied to".</P>
<DL>
<DT>
as source:<DD>any data object connected directly or indirectly with
this interface.
<DT>
as destination:<DD>any data object lying behind the router where the
interface belongs to.
</DL>

<H2><A NAME="pix_levels">PIX security levels</A></H2>
<P>PIX firewalls have a security level associated with each interface.
We don't want to expand our syntax to state them explicitly,
but instead we try to derive the level from the interface name:
<ul>
<li>Interface 'inside' gets level 100
<li>Interface 'outside' gets level 0
<li>For each other interface there must be a number at the end of its
name which is taken as the relative security level.<br> I.e 'DMZ-slot:4'
&lt; 'DMZ-slot:5'
</ul>
It is not necessary the find the exact level; what we need to know
is the relation of the security levels to each other.</P>

<H2><A NAME="redundant_rules">Automatic deletion of redundant rules</A></H2>
<P><em>Fully implemented, but documentation has to be done ...</em></P>

<H2><A NAME="generated_code">Generated Code</A></H2>
<UL>
<LI>ACL
<LI>Routing
<LI>Static commands for PIX
</UL>
<H2><A NAME="supported_devices">Supported devices</A></H2>
<UL>
<LI>PIX (only versions supporting access-lists, i.e. >= 5.x)
<LI>Cisco IOS with firewall feature set
<li>Cisco IOS without firewall feature set
</UL>

<P> Copyright (c) 2003, Heinz Knutzen 
<A HREF="mailto:heinzknutzen@users.berlios.de">heinzknutzen@users.berlios.de</A></P>

</BODY>

</HTML>
