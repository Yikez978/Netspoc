<HTML>
<HEAD>
<!-- $Id$ -->
<TITLE>Description Language for Security Policy and Topology</TITLE>
<style type="text/css">
<!--
body { background-color:white;
       margin-left:0.5cm;
       font-family:helvetica,arial,sans-serif;  }
h1 { font-size:20pt;
     color:maroon;
     text-align:center;
     border-bottom:solid thin black; }
h1 image { border-style:none;
           padding:0cm; }
  
pre {
  border-width:thin;
  border-style:solid;
  color:blue;
  border-color:black;
  padding:0.15cm; }
tt {
  color:blue; }
code {
  color:blue; }
image {
  border-width:thin;
  border-style:solid;
  padding:0.15cm; }
dt { 
  color:blue;
  font:bold; }
-->
</style>
</HEAD>

<BODY bgcolor=#FFFFFF>

<H1><A NAME="language">Description Language for Security Policy and Topology</A></H1>

<!--toc-->

<H2><A NAME="overview">Overview</A></H2>

<h3><a name="policies"></a>Policies</h3>

<ul>
<li>A policy is a set of related rules. 
<li>Network objects and service definitions are used in rules to
describe network traffic which can or must not pass from source to
destination.
<li>All rules of a single policy must refer to the same network
objects in their source or destination.
<li>Policies have a name which may be used for documentation or
reporting purposes.
</ul>

<H3><A NAME="network_objects">Network Objects</A></H3>
<UL>
<LI>Have name and IP address.
<LI>Describe the topology.
<LI>Can be used as source and destination of rules.
</UL>

<H3><A NAME="service_definitions">Service Definitions</A></H3>
<UL>
<LI>have a name
<LI>describe properties of network traffic as they typically can be
filtered by packet filters (i.e. type of protocol, port number)
</UL>

<H3><A NAME="groups">Groups</A></H3>
<UL>
<LI>have a name
<LI>are used to group network objects
<LI>are used in rules for simplified management of large numbers of
network objects.
</UL>

<H3><A NAME="service_groups">Service Groups</A></H3>
<UL>
<LI>
have a name
<LI>are used to group service definitions
<LI>are used in rules
</UL>

<h3>Crypto Definition</h3>

A <a href="#crypto_syntax">crypto definition</a> consists of three parts:
<ol>
<li>A definition of crypto tunnels.
<li>A set of rules describing which traffic has to be encrypted.
<li>A reference to another definition with details about the used
encryption method. Currently only IPSec is supported.
</ol>

Crypto definitions are very powerful: A large number of crypto tunnles of
either a hub and spoke topology or a fully meshed topology may be defined
easily. 

<H2><A NAME="detailed">Detailed description of network objects</A></H2>
<P>The topology is built from networks and routers.
A router and a network are connected by an interface.
Networks may have any number of hosts, which are located inside the
network.</P>
<P>Routers may be managed or unmanaged. For a managed router, NetSPoC
generates access control lists which control what traffic can pass
this router and what traffic is blocked.
The whole topology is partitioned into different security domains by
managed routers.</P>
<P>Special network objects called 'any' objects and 'every' objects may
be defined which denote all network objects inside a security domain.</P>

<H3><A NAME="general_syntax">General syntax</A></H3>
<P>All network objects and groups have a typed name like &lt;type&gt;:&lt;name&gt;.</P>
<P>&lt;name&gt; is build from one ore more alphanumerical characters together
with hyphen and underscore. The current locale settings are used,
i.e. accented characters are allowed for European locale settings.</P>
<P>&lt;ip-adr&gt; denotes an IP address. Currently NetSPoC handles IP v4
addresses n.n.n.n with 0 &lt;= n &lt;= 255</P>
<P>&lt;interface_name&gt; may contain any characters, even interspersed
whitespace. Currently characters from <CODE>[;,=]</CODE> are not allowed, since
we use them as delimiters.</P>
<P>&lt;int&gt; is an integer</P>
<P>Meta symbols in syntax definitions below:</P>
<UL>
<LI>&lt;..&gt; denote something defined elsewhere
<LI>[..] denotes an optional part
<LI>{{..|..}} denotes alternatives.
<P>Note: single { and } characters stand for themselves.</P>
<LI>... * means any number of the left part
</UL>

<H3><A NAME="network_definition">Network Definition</A></H3>
<H4>Syntax</H4>
<PRE>
  network:&lt;name&gt; = {
     {{
         ip = &lt;ip-adr&gt;; mask = &lt;ip-adr&gt;;
	 &lt;network NAT definition&gt; *
         [ route_hint; ]
	 [ subnet_of = network:&lt;name&gt;; ]
         &lt;host definition&gt; *
     |
         unnumbered
     }}
  }

  &lt;network NAT definition&gt; ::=
         nat:&lt;name&gt; = { 
	  ip = &lt;ip-adr&gt;; 
	  [ mask = &lt;ip-adr&gt;; ] 
	  [ dynamic; ]
	  [ subnet_of = network:&lt;name&gt;; ] 
	 }
</PRE>

<UL>
<LI>A network is described by an ip address and a mask or
<LI>may alternatively be marked as unnumbered.
<LI>It may contain any number of host definitions.
<LI>Unnumbered networks must have no host definitions at all.
<LI>If used as source or destination of a rule, the ip/mask is used
directly for generating ACLs.
<LI>An unnumbered network must not be used in rules.
<LI>All networks must be disjunct if option 'strict_subnets' is
active. Exceptions must be declared explictly:
<UL>
<LI>route_hint: This network may enclose other networks, but it must
not have host definitions.
<LI>subnet_of: The enclosing network must be stated explicitly.
</UL>
This may be useful for a large topology, where a network may easily be
redefined by mistake.
</UL>

<H3><A NAME="host_definition">Host definition</A></H3>
<H4>Syntax</H4>
<PRE>
  &lt;host definition&gt; ::=
        host:&lt;name&gt; = {   
	 {{
	   ip = &lt;ip-adr&gt;, ...;
         |
           range = &lt;ip-adr&gt; - &lt;ip-adr&gt;;
	 }}
           &lt;NAT definition&gt; *
        }

  &lt;NAT definition&gt; ::=
        nat:&lt;name&gt; = { ip = &lt;ip-adr&gt;; }
</PRE>

<UL>
<LI>A host may only be defined inside a network definition.
<LI>It has one or more IP addresses or
<LI>alternatively an ip address range with first address &lt; second address
<LI>IP addresses must match ip/mask of the surrounding network.
<LI>If used as source or destination of a rule, one ACL entry is
generated for each IP address.
<LI>NetSPoC tries to automatically convert successive IP addresses from one
or multiple hosts of a common network to an IP range.
<LI>During code generation, an IP range is split into a number of
subnetworks which cover the range. One ACL entry is generated for
each subnetwork.
</UL>

<H3><A NAME="router_definition">Router definition</A></H3>
<H4>Syntax</H4>
<PRE>
  &lt;router definition&gt; ::=
  router:&lt;name&gt; = {
     {{
        managed [ = {{ full | secondary }} ] ;
        model = &lt;name&gt;;
	[ no_group_code; ]
	&lt;interface definition&gt; *
     |
        [ model = &lt;name&gt;; ]
        {{ &lt;interface definition&gt; | &lt;short interface definition&gt; }} *
     }}
  }</PRE>
<UL>
<li>A router may be managed or unmanaged.
<li>Managed routers may be of type 'full' or of type 'secondary'. A
type 'full' is assumed, if no value is given. See <A
HREF="#secondary">secondary packet filters</A> below for a detailed
description. 
<LI>Managed routers need to be precisely described since this
 information is needed for code generation later.
<LI>The router model is used to generate correct code for different
 router models.<BR>Currently three models are supported:
<UL>
<LI>PIX for Cisco PIX firewalls
<LI>IOS_FW for Cisco IOS routers with state full inspection
<li>IOS for stateless Cisco IOS
</UL>
<font size="-1">Note: IOS_FW was named IOS before NetSPoC version 1.3
</font> 
<LI>NetSPoC generates optimized code using object groups for PIX firewalls and
chains for iptables. Use flag no_group_code to disable this optimization.
<LI>A Router may have any number of interface definitions.
<LI>For unmanaged routers, all attributes are optional.
<li>An interface definition without attributes is called a "short
interface definition".
</UL>

<H3><A NAME="interface_definition">Interface definition</A></H3>
<H4>Syntax</H4>
<PRE>
  &lt;interface definition&gt; ::= 
    interface:&lt;name&gt; = {
         {{ ip = &lt;ip-adr&gt;, ...; | unnumbered; }}
         &lt;NAT definition&gt; *
         [ &lt;NAT binding&gt; ]
	 [ &lt;virtual interface definition&gt; ]
         [ hardware = &lt;interface_name&gt;; ]
	 [ routing = {{ EIGRP | OSPF }}; ]
	 [ managed = {{ full | secondary }}; ]
	 [ reroute_permit = network:&lt;name&gt;, ...; ]
         [ disabled ; ]
    }

  &lt;NAT definition&gt; ::=
    nat:&lt;name&gt; = { ip = &lt;ip-adr&gt;; }
  &lt;NAT binding&gt; ::=
    nat = &lt;name&gt;;

  &lt;virtual interface definition&gt; ::=
    virtual = { 
         ip = &lt;ip-adr&gt;;
         type = {{ VRRP | HSRP }};
         [ id = &lt;int&gt;; ]
    }
        
  &lt;short interface definition&gt; ::=
    interface:&lt;name&gt;;
 </PRE>

<UL>
<LI>Interfaces have no name of their own; instead a network name is used
  to indicate that the interface is linked to a network of the same
  name.
<LI>An interface may have one or more IP addresses. All of them must
  match the IP/mask of the corresponding network.
<LI>An unnumbered interface must only be linked to an unnumbered network.
<li> A virtual interface defines a shared IP address and type of redundancy
  protocol. See <a name="#virtual"> Virtual interfaces</a> for details.
<LI>The 'hardware' attribute indicates, which hardware interface the router
  belongs to. This attribute is mandatory for managed routers.
<LI>Multiple interfaces may belong to the same hardware interface.
<li>A routing protocol may be activated for an interface. In this
 case, generation of static routing entries is disabled for this
 interface and access control lists for this interface are automatically
 augmented to permit incoming packets of the routing
 protocol. Currently EIGRP and OSPF are supported.
<li>By default, the filter level is declared for the whole router. This may be
  overridden for an interface. See <A HREF="#secondary">secondary packet
  filters</A> for details.
<li> For a description of attribute 'reroute_permit', 
 see <a href="#rerouting">Rerouting inside of security domains</a> below.
<LI>An interface may be marked as disabled.
  See <A HREF="#disabling">Disabling part of the topology</A> below.
<LI>For interface definitions of unmanaged routers all attributes
  may be left out.
<li>An interface definition without any attributes is called a "short
  interface definition".
<li> A short interface may only be used if there is no managed
  interface with static routing enabled in the same network. We need
  this requirement for getting all routing entries generated.
<LI>If used as source or destination of a rule an interface is handled
  like a host.
</UL>

<H3><A NAME="every_definition">'Every' object definition</A></H3>
<H4>Syntax</H4>
<PRE>
 every:&lt;name&gt; = { link = {{ network:&lt;name&gt;; | router:&lt;name&gt;; }} }</PRE>
<UL>
<LI>An 'every' definition is equivalent to a group of all networks of
a security domain.
<LI>It must not be linked to a managed router.
</UL>

<H3><A NAME="any_definition">'Any' object definition</A></H3>
<H4>Syntax</H4>
<PRE>
 any:&lt;name&gt; = { link = {{ network:&lt;name&gt;; |  router:&lt;name&gt;; }} }</PRE>
<UL>
<LI>An 'any' definition is used to represent all networks of a security domain.
<LI>It must not be linked to a managed router.
<LI>At most one 'any' object can be defined for a security domain.
<LI>Generated ACLs use 'any' (i.e. network 0.0.0.0/0.0.0.0) to prevent
enumeration of all networks of a security domain.
<LI>NetSPoC generates additional deny rules to prevent
intervening networks getting undesired access.
<LI>See <A HREF="#handling_any">Handling of 'any' objects</A> for details.
</UL>

<H3><A NAME="referencing">Referencing network objects</A></H3>
<H4>Syntax</H4>
<PRE>
 &lt;network object&gt; ::=
 {{
   host:&lt;name&gt; 
 | network:&lt;name&gt; 
 | interface:&lt;name&gt;.&lt;name&gt; 
 | interface:&lt;name&gt;.[auto]; 
 | interface:&lt;name&gt;.[all]; 
 | interface:[managed].[auto]; 
 | interface:[managed].[all]; 
 | interface:[all].[auto]; 
 | interface:[all].[all]; 
 | any:&lt;name&gt; 
 | any:[all]; 
 | any:[local];
 | every:&lt;name&gt;
 | group:&lt;name&gt; 
 }}</PRE>
<UL>
<LI>Network objects are referenced in groups or as source or destination
of rules.
<LI>When referencing interfaces, we need to use a different syntax than
for interface definitions: the router name followed by a network name.
<li>Special names [auto] and [all] may be used as network part in a
reference to an interface.
<ul>
 <li>[auto] denotes "the right side" of a router to reach src or
 dst in a rule.
 <li>[all] denotes <em>all</em> interfaces of a router.
</ul>
<li>Special names [managed] and [all] may be used as router part in a
reference to an interface.<ul>
<li>[managed] denotes an implicitly defined group of all
<em>managed</em> routers. 
<li>[all] denotes an implicitly defined group of <em>all</em>
routers.</ul>
<li>any:[all] denotes an implicitly defined group of <em>all</em>
'any' objects, i.e. security domains. This may be used in rules to permit
or deny traffic for the whole topology.
<li>any:[local] may only be used as src or dst in a rule where the counterpart
is an interface. In this case, any:[local] denotes the 'any' object, which is
directly attached to this interface.
</UL>

<H3><A NAME="groups_def">Groups of network objects</A></H3>
<H4>Syntax</H4>
<PRE> group:&lt;name&gt; = &lt;network object list&gt;;</PRE>
<p>with</p>
<PRE> &lt;network object list&gt; :== &lt;network object&gt;, ...</PRE>
<UL>
<LI>A group may be empty
<LI>A group may be defined by means of other groups
</UL>

<H3><A NAME="services">Services</A></H3>
<H4>Syntax</H4>
<PRE> service:&lt;name&gt; = 
 {{
   ip 
 | tcp [[&lt;range&gt; :] &lt;range&gt]
 | udp [[&lt;range&gt; :] &lt;range&gt]
 | icmp [&lt;int_1&gt;[/&lt;int_2&gt;]] 
 | proto &lt;int&gt; 
 }} ;</PRE>
<p>with</p>
<PRE> &lt;range&gt; ::= &lt;int_1&gt;[-&lt;int_2&gt;]
</PRE>
<P>
<DL>
<DT>tcp, udp
<DD>
<UL>
<li> A &lt;range&gt; denotes a tcp/udp port range
<li> A &lt;range&gt; consisting of only one number denotes a single
port
<li> An empty &lt;range&gt; is equivalent with the full range of all
ports 1 - 65535 
<li> If only one  &lt;range&gt; is given, it describes the destination
port
<li> If two  &lt;range&gt;s are given, they describe source and
destination port
<LI>0 &lt; &lt;int_1&gt; &lt;= &lt;int_2&gt; &lt;= 65535
</UL>
<P>
<DT>icmp
<DD>
<UL>
<LI>&lt;int_1&gt;, &lt;int_2&gt; denote icmp type and code
<LI>0 &lt;= &lt;int_1&gt;,&lt;int_2&gt; &lt;= 255
</UL>
<P>
<DT>protocol
<DD>
<UL>
<LI>&lt;int&gt; is a IP protocol number
<LI>0 &lt; &lt;int&gt; &lt;= 255
</UL>
</DL>
<ul>
<li>For describing a tcp connection between client and server, only
one rule is needed with client as source. The packets back from the
destination are allowed implicitly. 
<li>Similar to tcp connections, only one rule is needed to let udp
packets pass from source to destination and back.
<li>When using service "ip" in a rule, currently only packets from
source to destination are allowed. But state full packet filters let
pass answer packets for tcp connections anyway. To get a unified
handling for tcp, udp and ip for state full and stateless packet filters,
we might change this in the future, to let ip packets pass in both
directions, with only one rule.
</ul>

<H3><A NAME="groups_of_services">Groups of services</A></H3>
<H4>Syntax</H4>
<PRE>  servicegroup:&lt;name&gt; = &lt;service list&gt;;</PRE>
<P>with</P>
<PRE>
  &lt;service list&gt; ::= &lt;service&gt;, ...
  &lt;service&gt; ::= {{ service:&lt;name&gt; | servicegroup:&lt;name&gt; }}</PRE>
<UL>
<LI>A servicegroup may be empty.
<LI>A servicegroup may be defined by means of other servicegroups.
</UL>

<H3><A NAME="policies_def">Policies</A></H3>
<H4>Syntax</H4>
<PRE>
  policy:&lt;name&gt; = {
     [ &lt;description&gt; ]
     user = &lt;network object list&gt;;
     &lt;policy_rule&gt; * 
  }</PRE>
<P>with</P>
<PRE>
  &lt;policy_rule&gt; ::=
  {{ permit | deny }}
        src = &lt;policy_object&gt;;
        dst = &lt;policy_object&gt;;
        srv = &lt;service list&gt;;
  &lt;policy_object&gt; ::= {{ user | &lt;network object list&gt; }}
  &lt;description&gt; ::= description = any text up to end of line</PRE>
<UL>
<LI>Order of rules doesn't matter.
<LI>Deny rules override all permit rules.
<LI>Policies give a descriptive name to a group of related rules. 
<li>Policies are useful for documentation and reporting purposes. 
<li>The rules of a policy must be related in that they all use the same source
or destination object(s). This is enforced by the keyword "user" which
must be used either as src or dst or both parts of a rule.
</UL>

<h3><a name="restrict_def">Path restrictions</a></h3>
<H4>Syntax</H4>
<PRE> pathrestriction:&lt;name&gt; = 
  [ &lt;description&gt; ]
  &lt;interface list&gt; ;

  &lt;interface list&gt; ::= interface:&lt;name&gt;.&lt;name&gt;, ...
  &lt;description&gt; ::= description = any text up to end of line</PRE>
<ul>
 <li>Path restrictions are used to restrict paths inside cyclic
  subgraphs of the topology.
 <li>All paths running through two or more interfaces belonging to the
  same path restriction are discarded i. e. marked as invalid.
 <li>Only interfaces of managed routers may be referenced.
 <li>Path restrictions must not be used to discard <em>all</em> paths
  between some source / destination pair. Use a policy with deny rules instead.
</ul>

<h3><a name="global_NAT">Global NAT definition</a></h3>
<H4>Syntax</H4>
<PRE> nat:&lt;name&gt; = { 
 ip = &lt;ip-adr&gt;; 
 mask = &lt;ip-adr&gt;; 
 dynamic;
 [ subnet_of = network:&lt;name&gt;; ] 
}</PRE>

A global NAT definition may be used as a shortcut for applying multiple
identical dynamic NAT definitions to all networks in some area. See <a
href="#NAT">network address translation</a> for details.

<h2><a name="NAT">Network address translation (NAT)</a></h2>

Network address translation occurs at routers.
At one side of a router, a network object is visible with its original
IP address; at another side of the router this address is translated
to another address.

<p>Currently, NetSPoC supports static and dynamic NAT for whole
networks.

<p>For static NAT, the translated address uses the same netmask as the
original network. The translation is automatically applied to all host and
interface definitions of the translated network. A separate NAT
definition for hosts or interfaces is not possible in this case.

<p>For dynamic NAT, the translated address may use a different netmask than
the original network. Typically a smaller network is used for translation. IP
addresses are translated dynamically, hence hosts and interfaces of this
network are not visible from outside. But a dynamic translation of a network
may be augmented with static translations for single hosts or interfaces of
this network.

<p>Syntax for NAT is divided into two parts:
<ol>
<li>A <em>NAT definition</em> denominates the alternate IP address of an
network object.
<li>A <em>NAT binding</em> applies a set of NAT definitions to an
interface. 
</ol>

<h3>Example</h3>

Network "extern" has bad IP addresses, which are not usable at network
"intern". At router "r_ext" static NAT occurs. The NAT definition and
NAT binding tells NetSPoC, that and where NAT occurs.<br>
Hosts "extern_www" and "extern_mail" are visible with addresses
10.7.128.10 and 10.7.128.25 from "intern".

<pre>network:extern = {
 ip = 128.1.2.0; mask = 255.255.255.0;
 # static NAT definition
 nat:bad128 = { ip = 10.7.128.0; }
 host:extern_www = { ip = 128.1.2.10; }
 host:extern_mail = { ip = 128.1.2.25; }
}

router:r_ext = {
 interface:extern;
 interface:intern = {
  ip = 10.1.1.1;
  # NAT binding
  nat = bad128;
 }
}

network:intern = { ip = 10.1.1.0; mask = 255.255.255.0; }
</pre>

All NAT definitions with the same name establish a set of NAT
definitions.  A set of NAT definition is effective <em>behind</em>
that interface where the NAT binding with the same name occurs. We are
defining <em>behind an interface</em> as that part of the topology
which is seen when looking from the router to that interface.

<p>Multiple NAT definitions may be given for a single network. These are bound
to different interfaces to make different NAT definitions effective at
different parts of the topology.

<p>For dynamic NAT, multiple networks may use identical NAT definitions. This
is used to masquerade multiple networks to a single address space.

<p>A global NAT definition may be used as a shortcut for applying multiple
identical dynamic NAT definitions to all networks located <em>before</em> that
interface where the NAT binding with this name occurs.

<p>NetSPoC needs to know about NAT for different reasons:
<ol>
<li>When generating ACLs for an interface it must use those IP
    addresses which are visible in the area of this interface.
<li>The same is true when generating static routing entries.
<li>For some types of devices NetSPoC is able to actually generate the
   NAT translation rules. This is currently true for PIX firewalls.
</ol>

<h2><a name="secondary">Secondary packet filters</a></h2>
In a given topology we may get chains of managed packet filters
on the path from src to dst. Each packet filter is a "full" packet
filter by default, which does full filtering for each rule 
again and again.<br>
A secondary packet filter has simpler rules for	permitted traffic
which gets further filtering by a full packet filter. In this
case it allows any IP packets from the src network to the dst network.
This simple filtering assures that the traffic comes from the right
src and goes to the right dst.<br>
A secondary packet filter is declared with attribute
"managed = secondary". This may be useful if a router has not
enough memory for storing a complete set of filter rules and most of
the packets get fully filtered already by some other managed device.<br>
The filter level of each interface may be individually changed from the
default value declared for the whole router using attribute "managed" with
value "secondary" or "full". 

<h2><a name="routing">Routing</a></h2>

<h4>Static and dynamic routing</h4>
<p>From its knowledge about the topology, NetSPoC generates static
routing entries for each managed device. If an interface of a device
has an attribute "routing=&lt;routing protocol&gt;", no static routing
entries are generated for networks behind that interface.

<p>Routing entries are only generated for network objects, which are
used in some rule. I.e. no routing entries are generated for unused
parts of the topology. Even for network objects which are only used as
source of a rule, routing entries are generated, since stateful packet
filters implicitly allow answer packets back to the source. If an
'any' object is used in a rule, routing entries for all networks part
of this 'any' object are generated.

<h4>Default route</h4>
<p>A default route may be defined for a topology by placing a network
with IP address and mask equal 0.0.0.0. Such a network must have an
attribute "route_hint".

<p>Alternatively, NetSPoC can automatically define a default route for
each managed device as a means to reduce the number of static routing
entries. 
<ul>
<li>At each managed device, a default route is automatically inserted such
that it replaces the maximum number of routing entries. 
<li>This behavior may be switched on or off by option --auto_default_route.
<li>This option must be switched off, if a user defined default route is
given.
<li>This behavior is automatically disabled for routers where at least one
interface has dynamic routing enabled. 
</ul>

<h4>Optimization</h4>
Multiple routing entries for networks which are in a subnet
relation, are replaced by a single routing entry.

<h2><a name="rerouting">Rerouting inside of security domains</a></h2>

Internal traffic which flows inside a security domain isn't
filtered at all. Sometimes an interface X of a managed (filtering)
router is used as a default route for traffic which normally flows
inside a security domain. This would cause internal traffic to be
routed to X, which would deny this traffic.

<p>NetSPoC is prepared to handle this case by defining an attribute
'reroute_permit' for a managed interface. Value of this attribute is a
list of networks, for which any internal traffic should be allowed.

<h4>Example</h4>
router:x is managed, router:y is unmanaged.
<pre>
router:x -- network:a -- router:y -- network:b
</pre>


<p>network:a and network:b are inside one security domain, since
router:y isn't managed. If traffic from network:a to network:b is
routed via router:x and router:y, router:x would deny this traffic.
Use "reroute_permit = network:b" at "interface:x.a" to permit any
incoming traffic to network:b.
 
<h2><a name="virtual">Virtual interface</a></h2>
A virtual interface defines a shared IP address and type of redundancy
protocol at two or more interfaces. Currently, redundancy protocols VRRP and
HSRP are supported. 
<ul>
<li> The virtual IP address is used as destination when generating static
routes.
<li> Access control lists for the associated real interfaces are automatically
 augmented to permit incoming packets of the redundancy protocol.
<Li> At least two interfaces with the same virtual IP are needed.
<li> The set of interfaces with same virtual IP
<ul>
<li> must be linked to the same network and
<li> must be part of the same cyclic subgraph.
</ul>
<li> A virtual IP must be different from normal IP address(es).
<li> The 'id' attribute is optional. It is used for consistency checks but
currently not used when generating code for managed devices.
</ul>

<H2><A NAME="disabling">Disabling part of the topology</A></H2>
<P>An interface may be explicitly marked as disabled.  This implicitly
marks all network objects as disabled, that are located <em>behind</em>
this interface. We are defining <em>behind an interface</em> as that
part of the topology which is seen when looking from the router to
that interface. All occurrences of disabled network objects in groups and
rules are silently discarded.</P>

<h2><a name="encryption">Encryption</a></h2>
<h3><a name="crypto_syntax">Syntax</a></h3>
<pre>
  crypto:&lt;name&gt; = {
     [ &lt;description&gt; ]
     type = ipsec:&lt;name&gt;;
     hub = &lt;network object list&gt;; *
     spoke = &lt;network object list&gt;; *
     mesh = &lt;network object list&gt;; *
     &lt;crypto_rule&gt; * 
  }</PRE>
<P>with</P>
<PRE>
  &lt;crypto_rule&gt; ::=
  {{ permit | deny }}
        src = &lt;network object list&gt;;
        dst = &lt;network object list&gt;;
        srv = &lt;service list&gt;;
</PRE>

<pre>
  ipsec:&lt;name&gt; = {
     key_exchange = isakmp:&lt;name&gt;;
     esp_encryption = {{ aes | aes192 | des | 3des | none }};
     esp_authentication = {{ md5_hmac | sha_hmac | none }};
     ah = {{ md5_hmac | sha_hmac | none }};
     pfs_group = {{ 1 | 2 | 5 }};
     lifetime = &lt;number&gt; &lt;timeunit&gt;;
  }</pre>

<pre>
  isakmp:&lt;name&gt; = {
     identity = {{ address | fqdn }};
     nat_traversal = {{ on | off }};
     authentication = {{ preshare | rsasig }};
     encryption = {{ aes | aes192 | des | 3des }};
     hash = {{ md5 | sha }};
     group = {{ 1 | 2 | 5 }};
     lifetime = &lt;number&gt; &lt;timeunit&gt;;
  }</pre>
<P>with</P>
<PRE>
  &lt;timeunit&gt; ::= 
    {{ sec | min | hour | day | secs | mins | hours | days }};
</PRE>

<H2><A NAME="handling_any">Handling of 'any' objects</A></H2>
<P>The meaning of 'any' is different in a NetSPoC rule from that in an ACL.
For NetSPoC, any:X means "any network object of the security domain
where any:X is located".
For an ACL which filters incoming traffic of an interface, any
(i.e. 0.0.0.0/0.0.0.0) means "any network object beyond the interface
where the ACL is applied to".</P>
<DL>
<DT>
as source:<DD>any data object connected directly or indirectly with
this interface.
<DT>
as destination:<DD>any data object located behind the router where the
interface belongs to.
</DL>

<H2><A NAME="pix_levels">PIX security levels</A></H2>
<P>PIX firewalls have a security level associated with each interface.
We don't want to expand our syntax to state them explicitly,
but instead we try to derive the level from the interface name:
<ul>
<li>Interface 'inside' gets level 100
<li>Interface 'outside' gets level 0
<li>For each other interface there must be a number at the end of its
name which is taken as the relative security level.<br> I.e 'DMZ-slot:4'
&lt; 'DMZ-slot:5'
</ul>
It is not necessary the find the exact level; what we need to know
is the relation of the security levels to each other.</P>

<H2><A NAME="redundant_rules">Automatic deletion of redundant rules</A></H2>
<P><em>Fully implemented, but documentation has to be done ...</em></P>

<H2><A NAME="generated_code">Generated Code</A></H2>
<UL>
<LI>Access control lists
<LI>Routing
<LI>NAT commands for some devices
</UL>
<H2><A NAME="supported_devices">Supported devices</A></H2>
<UL>
<LI>PIX 
<ul>
<li>access-list (conduit and outbound are not supported)
<li>object-group
<li>icmp, telnet, ssh, http
<li>route
</ul>
<LI>Cisco IOS with firewall feature set
 <ul>
 <li>ip access-list extended
 <li>ip route
 </ul>
<li>Cisco IOS without firewall feature set
 <ul>
 <li>ip access-list extended (rules for answer packets are added automatically)
 <li>ip route
 </ul>
<li>Linux 
 <ul>
  <li>iptables 
  <li>ip route
 </ul>
</UL>

<P> Copyright (c) 2005, Heinz Knutzen 
<A HREF="mailto:heinzknutzen@users.berlios.de">heinzknutzen@users.berlios.de</A></P>

</BODY>
</HTML>

<!--  LocalWords:  Rerouting NetSPoC nat EIGRP OSPF src dst tcp udp icmp servicegroup
 -->
<!--  LocalWords:  servicegroups srv pathrestriction netmask www stateful DMZ
 -->
<!--  LocalWords:  iptables Knutzen denominates ACLs IOS VRRP HSRP
 -->
